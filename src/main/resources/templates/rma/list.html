<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PCD Manager - RMA List</title>
    <!-- Immediate theme application to prevent flash -->
    <script th:src="@{/js/theme-instant.js}"></script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    
    <!-- Data Table Component CSS -->
    <link th:href="@{/css/components/data-table.css}" rel="stylesheet">
    <link th:href="@{/dark-mode.css}" rel="stylesheet">
    <style>
        /* Apply smaller font only to table content, not headers or inputs */
        .content-area .data-table-compact {
            font-size: 0.9rem;
        }
        
        /* Override content-area font size for the main header to match Tools page */
        .content-area h2 {
            font-size: 2rem; /* Bootstrap default h2 size */
            font-weight: 500; /* Bootstrap default heading font-weight */
        }
        
        /* Ensure search inputs match Tools page size */
        .content-area .form-control {
            font-size: 1rem; /* Bootstrap default input size */
        }

        /* Popover for Problem Description - now handled by unified tooltip styling above */
        
        /* All tooltip icons - match tools list blue color */
        .tool-tooltip,
        .problem-popover-icon,
        .comment-icon.info-icon-interactive,
        .moving-parts-icon {
            cursor: pointer !important;
            color: #0d6efd !important; /* Bootstrap primary blue - same as tools list */
            transition: transform 0.2s;
        }
        
        .tool-tooltip:hover,
        .problem-popover-icon:hover,
        .comment-icon.info-icon-interactive:hover,
        .moving-parts-icon:hover {
            transform: scale(1.1);
            color: #0a58ca !important; /* Darker blue on hover - same as tools list */
        }
        
        /* RMA number styling - match tool name formatting exactly */
        .rma-number {
            font-weight: bold !important;
            /* No custom color - inherit theme default like tool names */
            text-decoration: none !important;
        }
        
        /* Clickable row styling - match tools list */
        .rma-row {
            cursor: pointer !important;
            transition: background-color 0.2s ease;
        }
        
        .rma-row:hover {
            background-color: rgba(0,123,255,0.1) !important; /* Match tools list hover */
        }
        
        /* Set specific alternating colors - dark and light */
        [data-bs-theme="dark"] .table-striped > tbody > tr:nth-of-type(odd) > td,
        [data-bs-theme="dark"] .table-striped > tbody > tr:nth-of-type(odd) > th {
            background-color: #292d30 !important;
        }
        
        [data-bs-theme="dark"] .table-striped > tbody > tr:nth-of-type(even) > td,
        [data-bs-theme="dark"] .table-striped > tbody > tr:nth-of-type(even) > th {
            background-color: #343a40 !important;
        }
        
        /* Prevent clicks on interactive elements from bubbling */
        .rma-row .problem-popover-icon,
        .rma-row .tool-tooltip,
        .rma-row .comment-icon,
        .rma-row .moving-parts-icon,
        .rma-row a {
            position: relative;
            z-index: 10;
        }
        
        /* Status and Priority badges - match Tools page exactly */
        .status-badge {
            font-size: 0.75rem !important;
            padding: 0.35em 0.65em !important; /* Match Bootstrap default badge padding */
        }
        
        .priority-badge {
            font-size: 0.75rem !important;
            padding: 0.35em 0.65em !important; /* Match Bootstrap default badge padding */
        }
        
        /* RMA-specific sorting arrows using Bootstrap icons */
        .sort-arrows {
            margin-left: 4px;
            display: inline-flex;
            flex-direction: column;
            line-height: 0.6;
            flex-shrink: 0;
        }
        
        /* RMA-specific status filter dropdown */
        .status-filter-header .dropdown-toggle {
            border: none;
            padding: 2px 6px;
        }
        .status-filter-header .dropdown-toggle:focus {
            box-shadow: none;
        }
        
        /* RMA-specific priority filter dropdown */
        .priority-filter-header .dropdown-toggle {
            border: none;
            padding: 2px 6px;
        }
        .priority-filter-header .dropdown-toggle:focus {
            box-shadow: none;
        }
        
        /* Status count badges - match tools list styling exactly */
        .status-count-square {
            display: inline-block;
            min-width: 20px;
            padding: 2px 4px;
            font-size: 0.75em;
            text-align: center;
            border-radius: 3px;
            margin-right: 8px;
        }
        
        /* Priority count badges - match tools list styling exactly */
        .priority-count-square {
            display: inline-block;
            min-width: 20px;
            padding: 2px 4px;
            font-size: 0.75em;
            text-align: center;
            border-radius: 3px;
            margin-right: 8px;
        }
        
        /* Status filter item layout */
        .status-filter-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            min-height: 32px;
            padding: 4px 0;
        }
        
        .status-filter-left {
            display: flex;
            align-items: center;
            flex: 1;
        }
        
        /* Priority filter item layout */
        .priority-filter-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            min-height: 32px;
            padding: 4px 0;
        }
        
        .priority-filter-left {
            display: flex;
            align-items: center;
            flex: 1;
        }
        
        /* Ensure minimum height for RMA list to prevent cutoff */
        .rma-table-container {
            min-height: 600px;
        }
        
        .card-body {
            min-height: 500px;
        }
        
        /* Status column responsive behavior */
        .status-badge {
            white-space: nowrap;
            min-width: fit-content;
        }
        
        /* Ensure status column doesn't get too narrow */
        .status-filter-header {
            min-width: 220px !important;
            width: 15% !important;
        }
        
        /* Ensure priority column doesn't get too narrow */
        .priority-filter-header {
            min-width: 140px !important;
            width: 10% !important;
        }
        
        /* Make parts column same width as status column */
        .parts-column {
            min-width: 220px !important;
            width: 15% !important;
        }
        
        /* Status cell content */
        td .status-badge {
            display: inline-block;
            max-width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        /* Priority cell content */
        td .priority-badge {
            display: inline-block;
            max-width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Empty message styling */
        #empty-message-row td {
            font-size: 1.1rem;
            padding: 3rem 1rem !important;
        }

        #empty-message-row .bi-inbox {
            opacity: 0.5;
        }

        /* Comment icon cursor styling */
        .comment-icon {
            cursor: pointer;
        }

        .comment-icon.info-icon-interactive {
            cursor: pointer;
        }
        
        /* Status badge hover effect - match tools list */
        .status-badge:hover {
            opacity: 0.8;
            cursor: pointer;
        }
        
        /* Match Tools page table row height and icon sizes exactly */
        .data-table-compact td {
            padding: 0.35rem 0.3rem !important; /* Slightly less top/bottom padding */
            font-size: 0.85rem !important; /* Match tools page exactly */
            vertical-align: middle !important;
            line-height: 1.1 !important; /* Tighter line-height */
            height: 35.2px !important; /* Force exact height match */
            box-sizing: border-box !important; /* Ensure padding is included in height */
        }
        
        /* Ensure icons are same size as Tools page */
        .bi {
            font-size: 1rem !important; /* Standard Bootstrap icon size */
        }
        
        /* Remove any extra margins/padding from badges and elements */
        .status-badge, .priority-badge {
            margin: 0 !important;
            line-height: 1 !important;
        }
        
        /* Remove spacing from icon elements */
        .problem-popover-icon, .tool-tooltip, .moving-parts-icon, .comment-icon {
            margin: 0 !important;
            line-height: 1 !important;
        }
        
        /* Parts list styling to minimize height */
        .list-unstyled {
            margin-bottom: 0 !important;
            line-height: 1.1 !important;
        }
        
        .list-unstyled li {
            font-size: 0.8rem !important;
            line-height: 1.1 !important;
            margin: 0 !important;
            padding: 0 !important;
        }
        
        /* Ensure spans and links don't add extra height */
        .rma-number, .text-decoration-hover-underline {
            line-height: 1.1 !important;
            margin: 0 !important;
        }
        
        /* Force table row height */
        .data-table-compact tbody tr {
            height: 35.2px !important;
            max-height: 35.2px !important;
        }
        
        /* Remove any border spacing that might add height */
        .table {
            border-spacing: 0 !important;
            border-collapse: collapse !important;
        }
    </style>
</head>
<body>
    <div th:replace="~{fragments/navigation :: navbar('rma')}"></div>

    <div class="container-fluid mt-4 content-area">
        <!-- Header Section -->
        <div class="d-flex justify-content-between align-items-center mb-4">
            <div>
                <h2>
                    <i class="fas fa-clipboard-list me-2"></i>
                    RMA Management
                </h2>
            </div>
            <div>
                <button type="button" class="btn btn-success me-2" id="exportToExcelBtn">
                    <i class="fas fa-file-excel me-1"></i>
                    Export to Excel
                </button>
                <a th:href="@{/rma/new}" class="btn btn-primary">
                    <i class="fas fa-plus me-1"></i>
                    New RMA
                </a>
            </div>
        </div>

        <!-- Data Table Container -->
        <div class="data-table-container">
            
            <!-- Search Controls -->
            <div class="row mb-3 align-items-center">
                <div class="col-md-8">
                    <div class="input-group">
                        <input 
                            type="text" 
                            class="form-control" 
                            id="rmaSearchInput"
                            placeholder="Search by tool, parts, or part number..."
                            aria-label="Search">
                        <button 
                            class="btn btn-outline-secondary" 
                            type="button" 
                            id="clearSearch"
                            title="Clear search">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                </div>
            </div>

            <!-- Loading Indicator -->
            <div th:if="${asyncLoading}" id="rma-loading-container" class="text-center py-5">
                <div class="spinner-border text-primary mb-3" role="status">
                    <span class="visually-hidden">Loading...</span>
                </div>
                <div class="mb-2">
                    <h5>Loading RMA Data...</h5>
                    <div class="progress" style="width: 300px; margin: 0 auto;">
                        <div id="rma-loading-progress" class="progress-bar progress-bar-striped progress-bar-animated" 
                             role="progressbar" style="width: 0%;" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">
                        </div>
                    </div>
                </div>
                <small class="text-muted">Please wait while we load your RMA data...</small>
            </div>

            <!-- Responsive Table Container -->
            <div class="data-table-responsive table-responsive rma-table-container" id="rma-table-container" th:style="${asyncLoading} ? 'display: none;' : ''">
                <table class="table table-striped data-table-compact" id="rma-table">
                        <thead>
                            <tr>
                                <th style="width: 11%;" class="sortable-header" data-sort="rma-number">
                                    <div class="header-content">
                                        <span class="header-text">RMA Number</span>
                                        <span class="sort-arrows">
                                            <i class="bi bi-caret-up sort-up"></i>
                                            <i class="bi bi-caret-down sort-down"></i>
                                        </span>
                                    </div>
                                </th>
                                <th style="width: 13%;" class="sortable-header" data-sort="tool">
                                    <div class="header-content">
                                        <span class="header-text">Tool</span>
                                        <span class="sort-arrows">
                                            <i class="bi bi-caret-up sort-up"></i>
                                            <i class="bi bi-caret-down sort-down"></i>
                                        </span>
                                    </div>
                                </th>
                                <th style="width: 15%; min-width: 220px;" class="parts-column">Parts</th>
                                <th style="width: 15%; min-width: 220px;" class="status-filter-header">
                                    Status
                                    <div class="dropdown d-inline-block ms-1">
                                        <button class="btn btn-sm btn-outline-secondary dropdown-toggle" type="button" id="statusFilterDropdown" data-bs-toggle="dropdown" aria-expanded="false">
                                            <i class="bi bi-funnel"></i>
                                        </button>
                                        <ul class="dropdown-menu p-2" aria-labelledby="statusFilterDropdown" style="min-width: 280px;">
                                            <li class="dropdown-item-text">
                                                <small class="text-muted">Filter by Status:</small>
                                                <button type="button" class="btn btn-sm btn-outline-primary ms-2" id="showAllStatuses">Show All</button>
                                                <button type="button" class="btn btn-sm btn-outline-secondary ms-1" id="selectNoneStatuses">Select None</button>
                                            </li>
                                            <li><hr class="dropdown-divider"></li>
                                            <li class="dropdown-item-text">
                                                <div class="status-filter-item">
                                                    <div class="status-filter-left">
                                                        <span class="badge bg-primary status-count-square status-count" data-status="RMA_WRITTEN_EMAILED">0</span>
                                                        <span>RMA Written - Emailed</span>
                                                    </div>
                                                    <input class="form-check-input status-filter" type="checkbox" value="RMA_WRITTEN_EMAILED" id="status-RMA_WRITTEN_EMAILED" checked>
                                                </div>
                                            </li>
                                            <li class="dropdown-item-text">
                                                <div class="status-filter-item">
                                                    <div class="status-filter-left">
                                                        <span class="badge bg-info status-count-square status-count" data-status="NUMBER_PROVIDED">0</span>
                                                        <span>RMA Number Provided</span>
                                                    </div>
                                                    <input class="form-check-input status-filter" type="checkbox" value="NUMBER_PROVIDED" id="status-NUMBER_PROVIDED" checked>
                                                </div>
                                            </li>
                                            <li class="dropdown-item-text">
                                                <div class="status-filter-item">
                                                    <div class="status-filter-left">
                                                        <span class="badge bg-secondary status-count-square status-count" data-status="MEMO_EMAILED">0</span>
                                                        <span>Shipping Memo Emailed</span>
                                                    </div>
                                                    <input class="form-check-input status-filter" type="checkbox" value="MEMO_EMAILED" id="status-MEMO_EMAILED" checked>
                                                </div>
                                            </li>
                                            <li class="dropdown-item-text">
                                                <div class="status-filter-item">
                                                    <div class="status-filter-left">
                                                        <span class="badge bg-warning text-dark status-count-square status-count" data-status="RECEIVED_PARTS">0</span>
                                                        <span>Received Parts</span>
                                                    </div>
                                                    <input class="form-check-input status-filter" type="checkbox" value="RECEIVED_PARTS" id="status-RECEIVED_PARTS" checked>
                                                </div>
                                            </li>
                                            <li class="dropdown-item-text">
                                                <div class="status-filter-item">
                                                    <div class="status-filter-left">
                                                        <span class="badge bg-danger status-count-square status-count" data-status="WAITING_CUSTOMER">0</span>
                                                        <span>Waiting on Customer</span>
                                                    </div>
                                                    <input class="form-check-input status-filter" type="checkbox" value="WAITING_CUSTOMER" id="status-WAITING_CUSTOMER" checked>
                                                </div>
                                            </li>
                                            <li class="dropdown-item-text">
                                                <div class="status-filter-item">
                                                    <div class="status-filter-left">
                                                        <span class="badge bg-danger status-count-square status-count" data-status="WAITING_FSE">0</span>
                                                        <span>Waiting on FSE</span>
                                                    </div>
                                                    <input class="form-check-input status-filter" type="checkbox" value="WAITING_FSE" id="status-WAITING_FSE" checked>
                                                </div>
                                            </li>
                                            <li class="dropdown-item-text">
                                                <div class="status-filter-item">
                                                    <div class="status-filter-left">
                                                        <span class="badge bg-success status-count-square status-count" data-status="COMPLETED">0</span>
                                                        <span>Completed</span>
                                                    </div>
                                                    <input class="form-check-input status-filter" type="checkbox" value="COMPLETED" id="status-COMPLETED" checked>
                                                </div>
                                            </li>
                                        </ul>
                                    </div>
                                </th>
                                <th style="width: 10%; min-width: 140px;" class="priority-filter-header">
                                    Priority
                                    <div class="dropdown d-inline-block ms-1">
                                        <button class="btn btn-sm btn-outline-secondary dropdown-toggle" type="button" id="priorityFilterDropdown" data-bs-toggle="dropdown" aria-expanded="false">
                                            <i class="bi bi-funnel"></i>
                                        </button>
                                        <ul class="dropdown-menu p-2" aria-labelledby="priorityFilterDropdown" style="min-width: 220px;">
                                            <li class="dropdown-item-text">
                                                <small class="text-muted">Filter by Priority:</small>
                                                <button type="button" class="btn btn-sm btn-outline-primary ms-2" id="showAllPriorities">Show All</button>
                                                <button type="button" class="btn btn-sm btn-outline-secondary ms-1" id="selectNonePriorities">Select None</button>
                                            </li>
                                            <li><hr class="dropdown-divider"></li>
                                            <li class="dropdown-item-text">
                                                <div class="priority-filter-item">
                                                    <div class="priority-filter-left">
                                                        <span class="badge bg-success priority-count-square priority-count" data-priority="LOW">0</span>
                                                        <span>Low</span>
                                                    </div>
                                                    <input class="form-check-input priority-filter" type="checkbox" value="LOW" id="priority-LOW" checked>
                                                </div>
                                            </li>
                                            <li class="dropdown-item-text">
                                                <div class="priority-filter-item">
                                                    <div class="priority-filter-left">
                                                        <span class="badge bg-primary priority-count-square priority-count" data-priority="MEDIUM">0</span>
                                                        <span>Medium</span>
                                                    </div>
                                                    <input class="form-check-input priority-filter" type="checkbox" value="MEDIUM" id="priority-MEDIUM" checked>
                                                </div>
                                            </li>
                                            <li class="dropdown-item-text">
                                                <div class="priority-filter-item">
                                                    <div class="priority-filter-left">
                                                        <span class="badge bg-warning text-dark priority-count-square priority-count" data-priority="HIGH">0</span>
                                                        <span>High</span>
                                                    </div>
                                                    <input class="form-check-input priority-filter" type="checkbox" value="HIGH" id="priority-HIGH" checked>
                                                </div>
                                            </li>
                                            <li class="dropdown-item-text">
                                                <div class="priority-filter-item">
                                                    <div class="priority-filter-left">
                                                        <span class="badge bg-danger priority-count-square priority-count" data-priority="URGENT">0</span>
                                                        <span>Urgent</span>
                                                    </div>
                                                    <input class="form-check-input priority-filter" type="checkbox" value="URGENT" id="priority-URGENT" checked>
                                                </div>
                                            </li>
                                        </ul>
                                    </div>
                                </th>
                                <th style="width: 7%;" class="sortable-header" data-sort="written-date">
                                    <div class="header-content">
                                        <span class="header-text">Written</span>
                                        <span class="sort-arrows">
                                            <i class="bi bi-caret-up sort-up"></i>
                                            <i class="bi bi-caret-down sort-down"></i>
                                        </span>
                                    </div>
                                </th>
                                <th style="width: 7%;" class="sortable-header" data-sort="rma-provided-date">
                                    <div class="header-content">
                                        <span class="header-text">RMA # Provided</span>
                                        <span class="sort-arrows">
                                            <i class="bi bi-caret-up sort-up"></i>
                                            <i class="bi bi-caret-down sort-down"></i>
                                        </span>
                                    </div>
                                </th>
                                <th style="width: 7%;" class="sortable-header" data-sort="shipping-memo-date">
                                    <div class="header-content">
                                        <span class="header-text">Shipping Memo</span>
                                        <span class="sort-arrows">
                                            <i class="bi bi-caret-up sort-up"></i>
                                            <i class="bi bi-caret-down sort-down"></i>
                                        </span>
                                    </div>
                                </th>
                                <th style="width: 8%;" class="sortable-header" data-sort="parts-received-date">
                                    <div class="header-content">
                                        <span class="header-text">Parts Received</span>
                                        <span class="sort-arrows">
                                            <i class="bi bi-caret-up sort-up"></i>
                                            <i class="bi bi-caret-down sort-down"></i>
                                        </span>
                                    </div>
                                </th>
                                <th style="width: 8%;" class="sortable-header" data-sort="parts-installed-date">
                                    <div class="header-content">
                                        <span class="header-text">Parts Installed</span>
                                        <span class="sort-arrows">
                                            <i class="bi bi-caret-up sort-up"></i>
                                            <i class="bi bi-caret-down sort-down"></i>
                                        </span>
                                    </div>
                                </th>
                                <th style="width: 8%;" class="sortable-header" data-sort="failed-parts-ready-date">
                                    <div class="header-content">
                                        <span class="header-text">Failed Parts Ready</span>
                                        <span class="sort-arrows">
                                            <i class="bi bi-caret-up sort-up"></i>
                                            <i class="bi bi-caret-down sort-down"></i>
                                        </span>
                                    </div>
                                </th>
                                <th style="width: 8%;" class="sortable-header" data-sort="failed-parts-shipped-date">
                                    <div class="header-content">
                                        <span class="header-text">Failed Parts Shipped</span>
                                        <span class="sort-arrows">
                                            <i class="bi bi-caret-up sort-up"></i>
                                            <i class="bi bi-caret-down sort-down"></i>
                                        </span>
                                    </div>
                                </th>
                                <th style="width: 5%;">Moving<br/>Parts</th>
                                <th style="width: 5%;">Comments</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr th:each="rma : ${rmas}" th:object="${rma}" class="data-table-row rma-row"
                                th:attr="data-tool=*{tool != null ? tool.name : ''},
                                         data-parts=${#strings.listJoin(rma.partLineItems.![partName ?: partNumber ?: productDescription], ' ')},
                                         data-part-numbers=${#strings.listJoin(rma.partLineItems.![partNumber], ' ')},
                                         data-rma-number=*{rmaNumber ?: sapNotificationNumber ?: ''},
                                         data-status=*{status != null ? status.name() : ''},
                                         data-priority=*{priority != null ? priority.name() : 'MEDIUM'},
                                         data-written-date=*{writtenDate != null ? #temporals.format(writtenDate, 'yyyy-MM-dd') : ''},
                                         data-rma-provided-date=*{rmaNumberProvidedDate != null ? #temporals.format(rmaNumberProvidedDate, 'yyyy-MM-dd') : ''},
                                         data-shipping-memo-date=*{shippingMemoEmailedDate != null ? #temporals.format(shippingMemoEmailedDate, 'yyyy-MM-dd') : ''},
                                         data-parts-received-date=*{partsReceivedDate != null ? #temporals.format(partsReceivedDate, 'yyyy-MM-dd') : ''},
                                         data-parts-installed-date=*{installedPartsDate != null ? #temporals.format(installedPartsDate, 'yyyy-MM-dd') : ''},
                                         data-failed-parts-ready-date=*{failedPartsPackedDate != null ? #temporals.format(failedPartsPackedDate, 'yyyy-MM-dd') : ''},
                                         data-failed-parts-shipped-date=*{failedPartsShippedDate != null ? #temporals.format(failedPartsShippedDate, 'yyyy-MM-dd') : ''}">
                                <!-- RMA Number & Problem Description Popover -->
                                <td>
                                    <span class="rma-number" th:text="*{rmaNumber != null and rmaNumber != '' ? rmaNumber : (sapNotificationNumber != null and sapNotificationNumber != '' ? sapNotificationNumber : 'N/A')}"></span>
                                    <!-- Problem details icon with lazy loading -->
                                    <i class="bi bi-info-circle-fill problem-popover-icon ms-1"
                                       th:attr="data-rma-id=*{id},
                                                data-rma-number=(*{rmaNumber} != null ? *{rmaNumber} : (*{sapNotificationNumber} != null ? *{sapNotificationNumber} : 'RMA-' + *{id}))"
                                       data-bs-toggle="popover"
                                       data-bs-placement="right"
                                       data-bs-trigger="hover focus click"
                                       data-bs-html="true"
                                       th:data-bs-title="'Problem Details for ' + (*{rmaNumber} != null ? *{rmaNumber} : (*{sapNotificationNumber} != null ? *{sapNotificationNumber} : 'RMA-' + *{id}))"
                                       data-bs-content="Loading problem details..."
                                       title="Hover to load problem details"></i>
                                </td>
                                <!-- Tool -->
                                <td>
                                    <a th:if="*{tool != null}" th:href="@{/tools/{id}(id=*{tool.id})}" th:text="*{tool.name}" class="text-decoration-hover-underline"></a>
                                    <span th:if="*{tool == null}">N/A</span>
                                    <span th:if="*{tool != null}">
                                        <i class="bi bi-info-circle-fill ms-1 tool-tooltip"
                                           th:attr="data-rma-id=*{id},
                                                    data-tool-name=*{tool.name}"
                                           data-bs-toggle="popover"
                                           data-bs-placement="right"
                                           data-bs-trigger="hover focus"
                                           data-bs-html="true"
                                           th:data-bs-title="*{tool.name}"
                                           data-bs-content="Loading tool details..."
                                           title="Hover to load tool details">
                                        </i>
                                    </span>
                                </td>
                                <!-- Parts -->
                                <td class="allow-wrap">
                                    <span th:if="${#lists.isEmpty(rma.partLineItems)}">N/A</span>
                                    <ul th:unless="${#lists.isEmpty(rma.partLineItems)}" class="list-unstyled mb-0" style="font-size: 0.9em;">
                                        <li th:each="item : *{partLineItems}" th:text="${item.partName ?: item.partNumber ?: item.productDescription}"></li>
                                    </ul>
                                </td>
                                <!-- Status -->
                                <td class="text-center">
                                    <span th:if="*{status != null}" th:switch="*{status.name()}">
                                        <span th:case="'RMA_WRITTEN_EMAILED'" class="badge rounded-pill bg-primary status-badge" th:text="*{status.displayName}"></span>
                                        <span th:case="'NUMBER_PROVIDED'" class="badge rounded-pill bg-info status-badge" th:text="*{status.displayName}"></span>
                                        <span th:case="'MEMO_EMAILED'" class="badge rounded-pill bg-secondary status-badge" th:text="*{status.displayName}"></span>
                                        <span th:case="'RECEIVED_PARTS'" class="badge rounded-pill bg-warning text-dark status-badge" th:text="*{status.displayName}"></span>
                                        <span th:case="'WAITING_CUSTOMER'" class="badge rounded-pill bg-danger status-badge" th:text="*{status.displayName}"></span>
                                        <span th:case="'WAITING_FSE'" class="badge rounded-pill bg-danger status-badge" th:text="*{status.displayName}"></span>
                                        <span th:case="'COMPLETED'" class="badge rounded-pill bg-success status-badge" th:text="*{status.displayName}"></span>
                                        <span th:case="*" class="badge rounded-pill bg-light text-dark status-badge" th:text="*{status.displayName}"></span>
                                    </span>
                                    <span th:if="*{status == null}" class="badge rounded-pill bg-light text-dark status-badge">N/A</span>
                                </td>
                                <!-- Priority -->
                                <td class="text-center">
                                    <span th:if="*{priority != null}" th:switch="*{priority.name()}">
                                        <span th:case="'LOW'" class="badge rounded-pill bg-success priority-badge" th:text="*{priority.displayName}"></span>
                                        <span th:case="'MEDIUM'" class="badge rounded-pill bg-primary priority-badge" th:text="*{priority.displayName}"></span>
                                        <span th:case="'HIGH'" class="badge rounded-pill bg-warning text-dark priority-badge" th:text="*{priority.displayName}"></span>
                                        <span th:case="'URGENT'" class="badge rounded-pill bg-danger priority-badge" th:text="*{priority.displayName}"></span>
                                        <span th:case="*" class="badge rounded-pill bg-light text-dark priority-badge" th:text="*{priority.displayName}"></span>
                                    </span>
                                    <span th:if="*{priority == null}" class="badge rounded-pill bg-primary priority-badge">Medium</span>
                                </td>
                                <!-- Written Date -->
                                <td th:text="*{writtenDate != null ? #temporals.format(writtenDate, 'MM/dd/yy') : '-'}"></td>
                                <!-- RMA # Provided Date -->
                                <td th:text="*{rmaNumberProvidedDate != null ? #temporals.format(rmaNumberProvidedDate, 'MM/dd/yy') : '-'}"></td>
                                <!-- Shipping Memo Emailed Date -->
                                <td th:text="*{shippingMemoEmailedDate != null ? #temporals.format(shippingMemoEmailedDate, 'MM/dd/yy') : '-'}"></td>
                                <!-- Parts Received Date -->
                                <td th:text="*{partsReceivedDate != null ? #temporals.format(partsReceivedDate, 'MM/dd/yy') : '-'}"></td>
                                <!-- Parts Installed Date -->
                                <td th:text="*{installedPartsDate != null ? #temporals.format(installedPartsDate, 'MM/dd/yy') : '-'}"></td>
                                <!-- Failed Parts Packed Date (as Failed Parts Ready) -->
                                <td th:text="*{failedPartsPackedDate != null ? #temporals.format(failedPartsPackedDate, 'MM/dd/yy') : '-'}"></td>
                                <!-- Failed Parts Shipped Date -->
                                <td th:text="*{failedPartsShippedDate != null ? #temporals.format(failedPartsShippedDate, 'MM/dd/yy') : '-'}"></td>
                                
                                <!-- Moving Parts -->
                                <td class="text-center">
                                    <span th:if="${movingPartsMap != null and movingPartsMap.containsKey(rma.id) and not #lists.isEmpty(movingPartsMap[rma.id])}">
                                        <i class="bi bi-arrow-left-right moving-parts-icon"
                                           data-bs-toggle="popover"
                                           data-bs-placement="left"
                                           data-bs-trigger="hover focus click"
                                           data-bs-html="true"
                                           th:attr="data-bs-title='Moving Parts (' + ${#lists.size(movingPartsMap[rma.id])} + ')'"
                                           th:data-bs-content="${#strings.listJoin(movingPartsMap[rma.id].![
                                               '<div><strong>' + (partName ?: 'Unknown Part') + '</strong><br>' +
                                               (fromTool != null ? fromTool.name : 'No Tool') + ' → ' +
                                               (hasDestinationChain() ? 
                                                   'Multiple Destinations' :
                                                   (toTool != null ? toTool.name : 'No Tool')
                                               ) + '</div>'
                                           ], '<hr style=&quot;margin: 8px 0;&quot;>')}"
                                        ></i>
                                    </span>
                                    <span th:if="${movingPartsMap == null or !movingPartsMap.containsKey(rma.id) or #lists.isEmpty(movingPartsMap[rma.id])}">
                                        <i class="bi bi-arrow-left-right text-muted"></i> <!-- Greyed out icon -->
                                    </span>
                                </td>

                                <!-- Comments -->
                                <td class="text-center">
                                    <!-- Comments icon with lazy loading -->
                                    <i class="bi bi-chat-dots-fill comment-icon"
                                       th:classappend="${rmaCommentsMap.get(rma.id) != null and rmaCommentsMap.get(rma.id) > 0 ? 'info-icon-interactive' : 'text-muted'}"
                                       th:attr="data-rma-id=*{id},
                                                data-comment-count=${rmaCommentsMap.get(rma.id) ?: 0},
                                                data-bs-toggle=${rmaCommentsMap.get(rma.id) != null and rmaCommentsMap.get(rma.id) > 0 ? 'popover' : null}"
                                       data-bs-placement="left"
                                       data-bs-trigger="hover focus click"
                                       data-bs-html="true"
                                       th:data-bs-title="'Comments (' + ${rmaCommentsMap.get(rma.id) ?: 0} + ')'"
                                       data-bs-content="Loading comments..."
                                       th:title="${rmaCommentsMap.get(rma.id) != null and rmaCommentsMap.get(rma.id) > 0 ? 'Hover to load comments' : null}"></i>
                                    
                                    <!-- Comment count -->
                                    <span th:text="${rmaCommentsMap.get(rma.id) ?: 0}" class="ms-1 small"></span>
                                </td>

                            </tr>
                        </tbody>
                    </table>
                </div>
                
                <!-- Results summary -->
                <div class="row mt-3">
                    <div class="col-md-6">
                        <small class="text-muted">
                            Showing <span id="rma-count">0</span> 
                            <span id="rma-count-text">RMAs</span>
                        </small>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // Initialize Bootstrap Dropdowns FIRST (before anything else)
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Initializing Bootstrap dropdowns...');
            
            // Initialize all dropdowns
            const dropdownElementList = [].slice.call(document.querySelectorAll('[data-bs-toggle="dropdown"]'));
            const dropdownList = dropdownElementList.map(function (dropdownToggleEl) {
                console.log('Initializing dropdown:', dropdownToggleEl.id);
                return new bootstrap.Dropdown(dropdownToggleEl);
            });
            
            console.log('Initialized', dropdownList.length, 'dropdowns');
        });
        
        // Initialize Bootstrap Popovers
        var popoverTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="popover"]'));
        var popoverList = popoverTriggerList.map(function (popoverTriggerEl) {
            return new bootstrap.Popover(popoverTriggerEl, {
                sanitize: false, // Allow HTML in content
                fallbackPlacements: ['left', 'top', 'bottom'],
                container: 'body' // Added to help with potential positioning/event issues
            });
        });
                
        // Close popovers when clicking outside
        document.addEventListener('click', function (event) {
            popoverList.forEach(function (popover) {
                var triggerElement = popover._element;
                var popoverId = triggerElement.getAttribute('aria-describedby');
                var popoverElement = popoverId ? document.getElementById(popoverId) : null;
                
                var isClickInsideTrigger = triggerElement.contains(event.target);
                var isClickInsidePopover = popoverElement ? popoverElement.contains(event.target) : false;
            
                // Hide popover if clicking outside both trigger and popover content
                if (!isClickInsideTrigger && !isClickInsidePopover) {
                    popover.hide();
                }
            });
        });

        // RMA Management functionality
        class RMAManager {
            constructor() {
                this.currentSort = null;
                this.sortDirection = 'asc';
                this.currentSearch = '';
                this.visibleStatuses = new Set(['RMA_WRITTEN_EMAILED', 'NUMBER_PROVIDED', 'MEMO_EMAILED', 'RECEIVED_PARTS', 'WAITING_CUSTOMER', 'WAITING_FSE', 'COMPLETED']);
                this.visiblePriorities = new Set(['LOW', 'MEDIUM', 'HIGH', 'URGENT']);
                this.totalStatusCounts = {}; // Track total counts across all RMAs
                this.totalPriorityCounts = {}; // Track total counts across all RMAs
                
                // Global caches for tooltip data that persist across DOM changes
                this.tooltipCache = {
                    comments: new Map(),        // rmaId -> {data, isLoaded, isLoading}
                    problemDetails: new Map(),  // rmaId -> {data, isLoaded, isLoading}
                    toolDetails: new Map(),     // rmaId -> {data, isLoaded, isLoading}
                    movingParts: new Map()      // rmaId -> {data, isLoaded, isLoading}
                };

                
                this.init();
                
                // Only calculate counts if there are rows (non-async mode)
                const existingRows = document.querySelectorAll('.rma-row');
                if (existingRows.length > 0) {
                    this.calculateTotalStatusCounts();
                    this.calculateTotalPriorityCounts();
                    this.updateStatusCounts();
                    this.updatePriorityCounts();
                    this.updateRmaCount();
                    
                    // Apply default sorting by written date (descending - most recent first)
                    this.applyDefaultSort();
                }
                
                // Bootstrap dropdowns are now initialized globally
                
                // Initialize interactions for tooltips and popovers
                this.initializeInteractions();
            }

            init() {
                // Search functionality
                const searchInput = document.getElementById('rmaSearchInput');
                const clearSearchButton = document.getElementById('clearSearch');
                
                searchInput.addEventListener('input', (e) => {
                    this.currentSearch = e.target.value.toLowerCase();
                    this.filterTable();
                });
                
                clearSearchButton.addEventListener('click', () => {
                    searchInput.value = '';
                    this.currentSearch = '';
                    this.filterTable();
                });

                // Sorting functionality
                document.querySelectorAll('.sortable-header').forEach(header => {
                    header.addEventListener('click', (e) => {
                        // Ignore clicks on dropdowns or their children
                        if (e.target.closest('[data-bs-toggle="dropdown"]') || 
                            e.target.closest('.dropdown') || 
                            e.target.closest('.dropdown-menu')) {
                            return; // Don't handle sort for dropdown clicks
                        }
                        
                        const sortType = header.getAttribute('data-sort');
                        this.handleSort(sortType, header);
                    });
                });

                // Status filtering
                document.querySelectorAll('.status-filter').forEach(checkbox => {
                    checkbox.addEventListener('change', (e) => {
                        const status = e.target.value;
                        if (e.target.checked) {
                            this.visibleStatuses.add(status);
                        } else {
                            this.visibleStatuses.delete(status);
                        }
                        this.filterTable();
                    });
                });

                // Show All button
                const showAllButton = document.getElementById('showAllStatuses');
                if (showAllButton) {
                    showAllButton.addEventListener('click', () => {
                        // Check all checkboxes
                        document.querySelectorAll('.status-filter').forEach(checkbox => {
                            checkbox.checked = true;
                            this.visibleStatuses.add(checkbox.value);
                        });
                        this.filterTable();
                    });
                }

                // Select None button
                const selectNoneButton = document.getElementById('selectNoneStatuses');
                if (selectNoneButton) {
                    selectNoneButton.addEventListener('click', () => {
                        // Uncheck all checkboxes
                        document.querySelectorAll('.status-filter').forEach(checkbox => {
                            checkbox.checked = false;
                            this.visibleStatuses.delete(checkbox.value);
                        });
                        this.filterTable();
                    });
                }

                // Priority filtering
                document.querySelectorAll('.priority-filter').forEach(checkbox => {
                    checkbox.addEventListener('change', (e) => {
                        const priority = e.target.value;
                        if (e.target.checked) {
                            this.visiblePriorities.add(priority);
                        } else {
                            this.visiblePriorities.delete(priority);
                        }
                        this.filterTable();
                    });
                });

                // Show All Priorities button
                const showAllPrioritiesButton = document.getElementById('showAllPriorities');
                if (showAllPrioritiesButton) {
                    showAllPrioritiesButton.addEventListener('click', () => {
                        // Check all checkboxes
                        document.querySelectorAll('.priority-filter').forEach(checkbox => {
                            checkbox.checked = true;
                            this.visiblePriorities.add(checkbox.value);
                        });
                        this.filterTable();
                    });
                }

                // Select None Priorities button
                const selectNonePrioritiesButton = document.getElementById('selectNonePriorities');
                if (selectNonePrioritiesButton) {
                    selectNonePrioritiesButton.addEventListener('click', () => {
                        // Uncheck all checkboxes
                        document.querySelectorAll('.priority-filter').forEach(checkbox => {
                            checkbox.checked = false;
                            this.visiblePriorities.delete(checkbox.value);
                        });
                        this.filterTable();
                    });
                }
            }

            handleSort(sortType, header) {
                // Remove sort classes from all headers
                document.querySelectorAll('.sortable-header').forEach(h => {
                    h.classList.remove('sort-asc', 'sort-desc');
                });

                // Determine sort direction
                if (this.currentSort === sortType) {
                    this.sortDirection = this.sortDirection === 'asc' ? 'desc' : 'asc';
                } else {
                    this.sortDirection = 'asc';
                }
                
                this.currentSort = sortType;
                header.classList.add(this.sortDirection === 'asc' ? 'sort-asc' : 'sort-desc');

                this.sortTable(sortType, this.sortDirection);
            }

            sortTable(sortType, direction) {
                const tbody = document.querySelector('tbody');
                const rows = Array.from(document.querySelectorAll('.rma-row'));

                rows.sort((a, b) => {
                    let aVal, bVal;

                    switch (sortType) {
                        case 'tool':
                            aVal = a.getAttribute('data-tool') || '';
                            bVal = b.getAttribute('data-tool') || '';
                            break;
                        case 'rma-number':
                            aVal = a.getAttribute('data-rma-number') || '';
                            bVal = b.getAttribute('data-rma-number') || '';
                            break;
                        case 'written-date':
                        case 'rma-provided-date':
                        case 'shipping-memo-date':
                        case 'parts-received-date':
                        case 'parts-installed-date':
                        case 'failed-parts-ready-date':
                        case 'failed-parts-shipped-date':
                            aVal = a.getAttribute(`data-${sortType}`) || '';
                            bVal = b.getAttribute(`data-${sortType}`) || '';
                            // Convert to date for comparison, empty dates go to end
                            aVal = aVal ? new Date(aVal) : new Date('9999-12-31');
                            bVal = bVal ? new Date(bVal) : new Date('9999-12-31');
                            break;
                        default:
                            return 0;
                    }

                    if (typeof aVal === 'string' && typeof bVal === 'string') {
                        return direction === 'asc' ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
                    } else {
                        return direction === 'asc' ? aVal - bVal : bVal - aVal;
                    }
                });

                // Clear and re-append sorted rows
                tbody.innerHTML = '';
                rows.forEach(row => tbody.appendChild(row));
            }

            filterTable() {
                const rows = document.querySelectorAll('.rma-row');
                const tbody = document.querySelector('tbody');
                
                // Check if no statuses or priorities are selected
                if (this.visibleStatuses.size === 0 || this.visiblePriorities.size === 0) {
                    // Hide all rows
                    rows.forEach(row => {
                        row.style.display = 'none';
                    });
                    
                    // Show empty message
                    this.showEmptyMessage();
                } else {
                    // Remove empty message if it exists
                    this.removeEmptyMessage();
                
                rows.forEach(row => {
                    const tool = row.getAttribute('data-tool').toLowerCase();
                    const parts = row.getAttribute('data-parts').toLowerCase();
                    const partNumbers = row.getAttribute('data-part-numbers').toLowerCase();
                    const rmaNumber = row.getAttribute('data-rma-number').toLowerCase();
                    const status = row.getAttribute('data-status');
                    const priority = row.getAttribute('data-priority');

                    // Check search criteria
                    const matchesSearch = !this.currentSearch || 
                        tool.includes(this.currentSearch) || 
                        parts.includes(this.currentSearch) || 
                        partNumbers.includes(this.currentSearch) ||
                        rmaNumber.includes(this.currentSearch);

                    // Check status filter
                    const matchesStatus = this.visibleStatuses.has(status);

                    // Check priority filter
                    const matchesPriority = this.visiblePriorities.has(priority);

                    if (matchesSearch && matchesStatus && matchesPriority) {
                        row.style.display = '';
                    } else {
                        row.style.display = 'none';
                    }
                });
                }

                this.updateStatusCounts();
                this.updatePriorityCounts();
                this.updateRmaCount();
            }

            updateRmaCount() {
                const visibleRows = document.querySelectorAll('.rma-row:not([style*="display: none"])');
                const count = visibleRows.length;
                document.getElementById('rma-count').textContent = count;
                document.getElementById('rma-count-text').textContent = count === 1 ? 'RMA' : 'RMAs';
            }

            showEmptyMessage() {
                const tbody = document.querySelector('tbody');
                const existingEmptyRow = document.getElementById('empty-message-row');
                
                if (!existingEmptyRow) {
                    // Count the number of columns in the header to span correctly
                    const headerCells = document.querySelectorAll('thead th');
                    const colSpan = headerCells.length;
                    
                    const emptyRow = document.createElement('tr');
                    emptyRow.id = 'empty-message-row';
                    emptyRow.innerHTML = `
                        <td colspan="${colSpan}" class="text-center text-muted py-5">
                            <i class="bi bi-inbox" style="font-size: 2rem;"></i>
                            <div class="mt-2">Empty</div>
                            <small>No status or priority filters selected</small>
                        </td>
                    `;
                    tbody.appendChild(emptyRow);
                }
            }

            removeEmptyMessage() {
                const existingEmptyRow = document.getElementById('empty-message-row');
                if (existingEmptyRow) {
                    existingEmptyRow.remove();
                }
            }

            calculateTotalStatusCounts() {
                // Count all RMAs by status (regardless of filters)
                document.querySelectorAll('.rma-row').forEach(row => {
                    const status = row.getAttribute('data-status');
                    if (status) {
                        this.totalStatusCounts[status] = (this.totalStatusCounts[status] || 0) + 1;
                    }
                });
            }

            calculateTotalPriorityCounts() {
                // Count all RMAs by priority (regardless of filters)
                document.querySelectorAll('.rma-row').forEach(row => {
                    const priority = row.getAttribute('data-priority');
                    if (priority) {
                        this.totalPriorityCounts[priority] = (this.totalPriorityCounts[priority] || 0) + 1;
                    }
                });
            }

            updateStatusCounts() {
                // Always show total counts, not filtered counts
                // This ensures counts don't disappear when everything is unchecked
                document.querySelectorAll('.status-count').forEach(badge => {
                    const status = badge.getAttribute('data-status');
                    badge.textContent = this.totalStatusCounts[status] || 0;
                });
            }

            updatePriorityCounts() {
                // Always show total counts, not filtered counts
                // This ensures counts don't disappear when everything is unchecked
                document.querySelectorAll('.priority-count').forEach(badge => {
                    const priority = badge.getAttribute('data-priority');
                    badge.textContent = this.totalPriorityCounts[priority] || 0;
                });
            }
            
            applyDefaultSort() {
                // Find the written date header and apply descending sort
                const writtenDateHeader = document.querySelector('[data-sort="written-date"]');
                if (writtenDateHeader) {
                    this.currentSort = 'written-date';
                    this.sortDirection = 'desc'; // Most recent first
                    writtenDateHeader.classList.add('sort-desc');
                    this.sortTable('written-date', 'desc');
                }
            }

            initializeInteractions() {
                // Re-initialize popovers for dynamically loaded content
                const popoverTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="popover"]'));
                popoverTriggerList.map(function (popoverTriggerEl) {
                    return new bootstrap.Popover(popoverTriggerEl, {
                        sanitize: false,
                        fallbackPlacements: ['left', 'top', 'bottom'],
                        container: 'body'
                    });
                });

                // Add click handlers for closing popovers
                document.addEventListener('click', function (event) {
                    const popovers = document.querySelectorAll('.popover');
                    popovers.forEach(function (popover) {
                        const trigger = document.querySelector(`[aria-describedby="${popover.id}"]`);
                        if (trigger && !trigger.contains(event.target) && !popover.contains(event.target)) {
                            const instance = bootstrap.Popover.getInstance(trigger);
                            if (instance) instance.hide();
                        }
                    });
                });
                
                // Initialize lazy loading for comments, problem details, tool details, and moving parts
                this.initLazyCommentLoading();
                this.initLazyProblemDetailsLoading();
                this.initLazyToolDetailsLoading();
                this.initLazyMovingPartsLoading();
                
                // Initialize clickable table rows
                this.initializeClickableRows();
            }
            
            initializeClickableRows() {
                // Add click handlers to all RMA rows
                document.querySelectorAll('.rma-row').forEach(row => {
                    // Remove any existing click handlers first
                    row.removeEventListener('click', this.handleRowClick);
                    
                    // Add new click handler
                    row.addEventListener('click', (event) => this.handleRowClick(event, row));
                });
            }
            
            handleRowClick(event, row) {
                // Don't navigate if we just finished dragging
                const tableContainer = document.querySelector('.rma-table-container');
                if (tableContainer && tableContainer.hasDragged) {
                    return;
                }
                
                // Check if the click was on an interactive element (icon, link, etc.)
                const target = event.target;
                const isInteractiveElement = target.closest('.problem-popover-icon, .tool-tooltip, .comment-icon, .moving-parts-icon, a, [data-bs-toggle]');
                
                // If clicking on an interactive element, don't navigate
                if (isInteractiveElement) {
                    return;
                }
                
                // Get the RMA ID from the row
                const rmaId = this.getRmaIdFromRow(row);
                if (rmaId) {
                    // Navigate to RMA details page
                    window.location.href = `/rma/${rmaId}`;
                }
            }
            
            getRmaIdFromRow(row) {
                // First try to get RMA ID from the row's data attribute (for dynamic rows)
                const rmaId = row.getAttribute('data-rma-id');
                if (rmaId) {
                    return rmaId;
                }
                
                // Fallback to getting RMA ID from icon elements (for server-rendered rows)
                const problemIcon = row.querySelector('.problem-popover-icon');
                if (problemIcon) {
                    return problemIcon.getAttribute('data-rma-id');
                }
                
                const commentIcon = row.querySelector('.comment-icon');
                if (commentIcon) {
                    return commentIcon.getAttribute('data-rma-id');
                }
                
                const toolIcon = row.querySelector('.tool-tooltip');
                if (toolIcon) {
                    return toolIcon.getAttribute('data-rma-id');
                }
                
                return null;
            }

            initLazyCommentLoading() {
                const self = this; // Capture 'this' reference
                const commentIcons = document.querySelectorAll('.comment-icon');
                console.log(`Found ${commentIcons.length} comment icons`);
                
                commentIcons.forEach(icon => {
                    const rmaId = icon.getAttribute('data-rma-id');
                    if (!rmaId) return;
                    
                    // Check comment count first - don't initialize popover for 0 comments
                    const commentCount = parseInt(icon.getAttribute('data-comment-count') || '0');
                    if (commentCount === 0) {
                        return; // Skip initialization entirely for 0 comments
                    }
                    
                    // Get or create cache entry for this RMA
                    if (!self.tooltipCache.comments.has(rmaId)) {
                        self.tooltipCache.comments.set(rmaId, {
                            data: null,
                            isLoaded: false,
                            isLoading: false,
                            currentRequest: null
                        });
                    }
                    
                    const cacheEntry = self.tooltipCache.comments.get(rmaId);
                    
                    // Ensure popover is initialized with the original content
                    const popover = bootstrap.Popover.getInstance(icon);
                    if (!popover) {
                        new bootstrap.Popover(icon, {
                            html: true,
                            placement: 'left',
                            trigger: 'hover focus click',
                            title: icon.getAttribute('data-bs-title') || 'Comments',
                            content: icon.getAttribute('data-bs-content') || 'Loading comments...',
                            sanitize: false,
                            fallbackPlacements: ['left', 'top', 'bottom'],
                            container: 'body'
                        });
                    }
                    
                    icon.addEventListener('mouseenter', async () => {
                        const commentCount = parseInt(icon.getAttribute('data-comment-count') || '0');
                        
                        // Don't load if no comments
                        if (commentCount === 0) return;
                        
                        // If already loaded, show cached data immediately
                        if (cacheEntry.isLoaded && cacheEntry.data) {
                            console.log(`Using cached comments for RMA ${rmaId}`);
                            const formattedComments = self.formatCommentsForPopover(cacheEntry.data.comments);
                            
                            // Always dispose and recreate popover to ensure fresh content
                            const currentPopover = bootstrap.Popover.getInstance(icon);
                            if (currentPopover) {
                                currentPopover.dispose();
                            }
                            
                            // Create new popover with cached content and show it immediately
                            const newPopover = new bootstrap.Popover(icon, {
                                html: true,
                                placement: 'left',
                                trigger: 'hover focus click',
                                title: `Comments (${cacheEntry.data.count})`,
                                content: formattedComments,
                                sanitize: false,
                                fallbackPlacements: ['left', 'top', 'bottom'],
                                container: 'body'
                            });
                            newPopover.show();
                            return;
                        }
                        
                        // Cancel any existing request
                        if (cacheEntry.currentRequest && !cacheEntry.currentRequest.signal.aborted) {
                            cacheEntry.currentRequest.abort();
                            cacheEntry.isLoading = false; // Reset loading state when we abort
                        }
                        
                        // Don't start new request if already loading
                        if (cacheEntry.isLoading) {
                            return;
                        }
                        
                        // Create new AbortController for this request
                        const abortController = new AbortController();
                        cacheEntry.currentRequest = abortController;
                        cacheEntry.isLoading = true;
                        
                        try {
                            console.log(`Loading comments for RMA ${rmaId} (cache miss)`);
                            const response = await fetch(`/rma/api/rma/${rmaId}/comments`, {
                                signal: abortController.signal
                            });
                            console.log('Response status:', response.status);
                            
                            if (!response.ok) {
                                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                            }
                            
                            const data = await response.json();
                            console.log('Response data:', data);
                            
                            if (data.success && data.comments) {
                                // Cache the data
                                cacheEntry.data = data;
                                cacheEntry.isLoaded = true;
                                
                                const formattedComments = self.formatCommentsForPopover(data.comments);
                                
                                // Update the existing popover's content
                                const currentPopover = bootstrap.Popover.getInstance(icon);
                                if (currentPopover) {
                                    // Update the popover's tip content if it's already shown
                                    const popoverTip = currentPopover.tip;
                                    if (popoverTip) {
                                        const popoverBody = popoverTip.querySelector('.popover-body');
                                        if (popoverBody) {
                                            popoverBody.innerHTML = formattedComments;
                                        }
                                        const popoverHeader = popoverTip.querySelector('.popover-header');
                                        if (popoverHeader) {
                                            popoverHeader.textContent = `Comments (${data.count})`;
                                        }
                                    }
                                    
                                    // Also update the data attributes for future shows
                                    icon.setAttribute('data-bs-content', formattedComments);
                                    icon.setAttribute('data-bs-title', `Comments (${data.count})`);
                                }
                            } else {
                                console.error('Failed to load comments:', data.error);
                                const currentPopover = bootstrap.Popover.getInstance(icon);
                                if (currentPopover) {
                                    const popoverTip = currentPopover.tip;
                                    if (popoverTip) {
                                        const popoverBody = popoverTip.querySelector('.popover-body');
                                        if (popoverBody) {
                                            popoverBody.innerHTML = 'Error loading comments';
                                        }
                                    }
                                    icon.setAttribute('data-bs-content', 'Error loading comments');
                                }
                            }
                        } catch (error) {
                            // Don't show error if request was aborted (user moved mouse away quickly)
                            if (error.name === 'AbortError') {
                                console.log('Request aborted for comments loading');
                                return;
                            }
                            
                            console.error('Error loading comments:', error);
                            const currentPopover = bootstrap.Popover.getInstance(icon);
                            if (currentPopover) {
                                const popoverTip = currentPopover.tip;
                                if (popoverTip) {
                                    const popoverBody = popoverTip.querySelector('.popover-body');
                                    if (popoverBody) {
                                        popoverBody.innerHTML = 'Error loading comments';
                                    }
                                }
                                icon.setAttribute('data-bs-content', 'Error loading comments');
                            }
                        } finally {
                            // Only reset loading state if this request wasn't aborted
                            if (!abortController.signal.aborted) {
                                cacheEntry.isLoading = false;
                            }
                        }
                    });
                });
            }

            initLazyProblemDetailsLoading() {
                const self = this;
                const problemIcons = document.querySelectorAll('.problem-popover-icon');
                console.log(`Found ${problemIcons.length} problem detail icons`);
                
                problemIcons.forEach(icon => {
                    const rmaId = icon.getAttribute('data-rma-id');
                    if (!rmaId) return;
                    
                    // Get or create cache entry for this RMA
                    if (!self.tooltipCache.problemDetails.has(rmaId)) {
                        self.tooltipCache.problemDetails.set(rmaId, {
                            data: null,
                            isLoaded: false,
                            isLoading: false,
                            currentRequest: null
                        });
                    }
                    
                    const cacheEntry = self.tooltipCache.problemDetails.get(rmaId);
                    
                    icon.addEventListener('mouseenter', async () => {
                        // If already loaded, show cached data immediately
                        if (cacheEntry.isLoaded && cacheEntry.data) {
                            console.log(`Using cached problem details for RMA ${rmaId}`);
                            const formattedDetails = self.formatProblemDetailsForPopover(cacheEntry.data.problemDetails);
                            icon.setAttribute('data-bs-content', formattedDetails);
                            
                            // Always dispose and recreate popover to ensure fresh content
                            const currentPopover = bootstrap.Popover.getInstance(icon);
                            if (currentPopover) {
                                currentPopover.dispose();
                            }
                            
                            // Create new popover with cached content and show it immediately
                            const newPopover = new bootstrap.Popover(icon, {
                                html: true,
                                placement: 'right',
                                trigger: 'hover focus click',
                                title: icon.getAttribute('data-bs-title') || 'Problem Details',
                                content: formattedDetails,
                                sanitize: false,
                                fallbackPlacements: ['left', 'top', 'bottom'],
                                container: 'body'
                            });
                            newPopover.show();
                            return;
                        }
                        
                        // Cancel any existing request
                        if (cacheEntry.currentRequest && !cacheEntry.currentRequest.signal.aborted) {
                            cacheEntry.currentRequest.abort();
                            cacheEntry.isLoading = false;
                        }
                        
                        if (cacheEntry.isLoading) return;
                        
                        const abortController = new AbortController();
                        cacheEntry.currentRequest = abortController;
                        cacheEntry.isLoading = true;
                        
                        try {
                            console.log(`Loading problem details for RMA ${rmaId} (cache miss)`);
                            const response = await fetch(`/rma/${rmaId}/problem-details`, {
                                signal: abortController.signal
                            });
                            
                            if (!response.ok) {
                                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                            }
                            
                            const data = await response.json();
                            
                            if (data.success && data.problemDetails) {
                                cacheEntry.data = data;
                                cacheEntry.isLoaded = true;
                                
                                const formattedDetails = self.formatProblemDetailsForPopover(data.problemDetails);
                                icon.setAttribute('data-bs-content', formattedDetails);
                                
                                const currentPopover = bootstrap.Popover.getInstance(icon);
                                if (currentPopover) {
                                    const popoverTip = currentPopover.tip;
                                    if (popoverTip && document.body.contains(popoverTip)) {
                                        const popoverBody = popoverTip.querySelector('.popover-body');
                                        if (popoverBody) {
                                            popoverBody.innerHTML = formattedDetails;
                                        }
                                    }
                                }
                            }
                        } catch (error) {
                            if (error.name === 'AbortError') return;
                            console.error('Error loading problem details:', error);
                        } finally {
                            if (!abortController.signal.aborted) {
                                cacheEntry.isLoading = false;
                            }
                        }
                    });
                });
            }

            initLazyToolDetailsLoading() {
                const self = this;
                const toolIcons = document.querySelectorAll('.tool-tooltip');
                console.log(`Found ${toolIcons.length} tool detail icons`);
                
                toolIcons.forEach(icon => {
                    const rmaId = icon.getAttribute('data-rma-id');
                    if (!rmaId) return;
                    
                    if (!self.tooltipCache.toolDetails.has(rmaId)) {
                        self.tooltipCache.toolDetails.set(rmaId, {
                            data: null,
                            isLoaded: false,
                            isLoading: false,
                            currentRequest: null
                        });
                    }
                    
                    const cacheEntry = self.tooltipCache.toolDetails.get(rmaId);
                    
                    icon.addEventListener('mouseenter', async () => {
                        if (cacheEntry.isLoaded && cacheEntry.data) {
                            console.log(`Using cached tool details for RMA ${rmaId}`);
                            const formattedDetails = self.formatToolDetailsForPopover(cacheEntry.data.toolDetails);
                            icon.setAttribute('data-bs-content', formattedDetails);
                            
                            // Always dispose and recreate popover to ensure fresh content
                            const currentPopover = bootstrap.Popover.getInstance(icon);
                            if (currentPopover) {
                                currentPopover.dispose();
                            }
                            
                            // Create new popover with cached content and show it immediately
                            const newPopover = new bootstrap.Popover(icon, {
                                html: true,
                                placement: 'right',
                                trigger: 'hover focus click',
                                title: icon.getAttribute('data-bs-title') || 'Tool Details',
                                content: formattedDetails,
                                sanitize: false,
                                fallbackPlacements: ['left', 'top', 'bottom'],
                                container: 'body'
                            });
                            newPopover.show();
                            return;
                        }
                        
                        if (cacheEntry.currentRequest && !cacheEntry.currentRequest.signal.aborted) {
                            cacheEntry.currentRequest.abort();
                            cacheEntry.isLoading = false;
                        }
                        
                        if (cacheEntry.isLoading) return;
                        
                        const abortController = new AbortController();
                        cacheEntry.currentRequest = abortController;
                        cacheEntry.isLoading = true;
                        
                        try {
                            console.log(`Loading tool details for RMA ${rmaId} (cache miss)`);
                            const response = await fetch(`/rma/api/rma/${rmaId}/tool-details`, {
                                signal: abortController.signal
                            });
                            
                            if (!response.ok) {
                                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                            }
                            
                            const data = await response.json();
                            
                            if (data.success && data.hasTool && data.toolDetails) {
                                cacheEntry.data = data;
                                cacheEntry.isLoaded = true;
                                
                                const formattedDetails = self.formatToolDetailsForPopover(data.toolDetails);
                                icon.setAttribute('data-bs-content', formattedDetails);
                                
                                const currentPopover = bootstrap.Popover.getInstance(icon);
                                if (currentPopover) {
                                    const popoverTip = currentPopover.tip;
                                    if (popoverTip && document.body.contains(popoverTip)) {
                                        const popoverBody = popoverTip.querySelector('.popover-body');
                                        if (popoverBody) {
                                            popoverBody.innerHTML = formattedDetails;
                                        }
                                    }
                                }
                            }
                        } catch (error) {
                            if (error.name === 'AbortError') return;
                            console.error('Error loading tool details:', error);
                        } finally {
                            if (!abortController.signal.aborted) {
                                cacheEntry.isLoading = false;
                            }
                        }
                    });
                });
            }

            initLazyMovingPartsLoading() {
                const self = this;
                const movingPartsIcons = document.querySelectorAll('.moving-parts-icon');
                console.log(`Found ${movingPartsIcons.length} moving parts icons`);
                
                movingPartsIcons.forEach(icon => {
                    const rmaId = icon.getAttribute('data-rma-id');
                    if (!rmaId) return;
                    
                    if (!self.tooltipCache.movingParts.has(rmaId)) {
                        self.tooltipCache.movingParts.set(rmaId, {
                            data: null,
                            isLoaded: false,
                            isLoading: false,
                            currentRequest: null
                        });
                    }
                    
                    const cacheEntry = self.tooltipCache.movingParts.get(rmaId);
                    
                    const popover = bootstrap.Popover.getInstance(icon);
                    if (!popover) {
                        new bootstrap.Popover(icon, {
                            html: true,
                            placement: 'left',
                            trigger: 'hover focus click',
                            title: 'Moving Parts',
                            content: 'Loading moving parts...',
                            sanitize: false,
                            fallbackPlacements: ['right', 'top', 'bottom'],
                            container: 'body'
                        });
                    }
                    
                    icon.addEventListener('mouseenter', async () => {
                        if (cacheEntry.isLoaded && cacheEntry.data) {
                            console.log(`Using cached moving parts for RMA ${rmaId}`);
                            const formattedParts = self.formatMovingPartsForPopover(cacheEntry.data.movingParts);
                            icon.setAttribute('data-bs-content', formattedParts);
                            
                            const currentPopover = bootstrap.Popover.getInstance(icon);
                            if (currentPopover) {
                                const popoverTip = currentPopover.tip;
                                if (popoverTip && document.body.contains(popoverTip)) {
                                    const popoverBody = popoverTip.querySelector('.popover-body');
                                    if (popoverBody) {
                                        popoverBody.innerHTML = formattedParts;
                                    }
                                }
                            }
                            return;
                        }
                        
                        if (cacheEntry.currentRequest && !cacheEntry.currentRequest.signal.aborted) {
                            cacheEntry.currentRequest.abort();
                            cacheEntry.isLoading = false;
                        }
                        
                        if (cacheEntry.isLoading) return;
                        
                        const abortController = new AbortController();
                        cacheEntry.currentRequest = abortController;
                        cacheEntry.isLoading = true;
                        
                        try {
                            console.log(`Loading moving parts for RMA ${rmaId} (cache miss)`);
                            const response = await fetch(`/rma/api/test-moving-parts/${rmaId}`, {
                                signal: abortController.signal
                            });
                            
                            if (!response.ok) {
                                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                            }
                            
                            const data = await response.json();
                            
                            if (data.success && data.movingParts) {
                                cacheEntry.data = data;
                                cacheEntry.isLoaded = true;
                                
                                const formattedParts = self.formatMovingPartsForPopover(data.movingParts);
                                icon.setAttribute('data-bs-content', formattedParts);
                                
                                const currentPopover = bootstrap.Popover.getInstance(icon);
                                if (currentPopover) {
                                    const popoverTip = currentPopover.tip;
                                    if (popoverTip && document.body.contains(popoverTip)) {
                                        const popoverBody = popoverTip.querySelector('.popover-body');
                                        if (popoverBody) {
                                            popoverBody.innerHTML = formattedParts;
                                        }
                                    }
                                }
                            }
                        } catch (error) {
                            if (error.name === 'AbortError') return;
                            console.error('Error loading moving parts:', error);
                        } finally {
                            if (!abortController.signal.aborted) {
                                cacheEntry.isLoading = false;
                            }
                        }
                    });
                });
            }

            formatCommentsForPopover(comments) {
                if (!comments || comments.length === 0) return 'No comments available';
                return comments.map(comment => {
                    const date = comment.createdDate ? new Date(comment.createdDate).toLocaleDateString() : '';
                    const user = comment.user?.name || 'Unknown';
                    return `<div class="mb-2"><small class="text-muted">${date} by ${user}</small><br/>${comment.content || 'No content'}</div>`;
                }).join('<hr class="my-1"/>');
            }

            formatProblemDetailsForPopover(problemDetails) {
                const formatDate = (dateStr) => {
                    if (!dateStr) return '-';
                    try {
                        const date = new Date(dateStr);
                        return date.toLocaleDateString('en-US', { month: '2-digit', day: '2-digit', year: '2-digit' });
                    } catch {
                        return '-';
                    }
                };

                return `<strong>Who:</strong> ${problemDetails.problemDiscoverer || '-'}<br>` +
                       `<strong>When:</strong> ${formatDate(problemDetails.problemDiscoveryDate)}<br>` +
                       `<strong>What:</strong> ${problemDetails.whatHappened || '-'}<br>` +
                       `<strong>Why:</strong> ${problemDetails.whyAndHowItHappened || '-'}<br>` +
                       `<strong>How:</strong> ${problemDetails.howContained || '-'}<br>` +
                       `<strong>By:</strong> ${problemDetails.whoContained || '-'}`;
            }

            formatToolDetailsForPopover(toolDetails) {
                let result = `<strong>Type:</strong> ${toolDetails.toolType || 'Unknown Type'}<br>`;
                
                // Handle model display
                const models = [toolDetails.model1, toolDetails.model2].filter(Boolean);
                if (models.length > 0) {
                    result += `<strong>Model:</strong> ${models.join('/')}<br>`;
                }
                
                // Handle serial number display
                const serials = [toolDetails.serialNumber1, toolDetails.serialNumber2].filter(Boolean);
                if (serials.length > 0) {
                    result += `<strong>Serial:</strong> ${serials.join('/')}`;
                }
                
                return result;
            }

            formatMovingPartsForPopover(movingParts) {
                if (!movingParts || movingParts.length === 0) return 'No moving parts';
                
                const formatDate = (dateStr) => {
                    if (!dateStr) return '-';
                    try {
                        const date = new Date(dateStr);
                        return date.toLocaleDateString('en-US', { month: '2-digit', day: '2-digit', year: '2-digit' });
                    } catch {
                        return '-';
                    }
                };
                
                return movingParts.map(part => {
                    return `<div class="mb-2">
                        <strong>${part.partName || 'Unknown Part'}</strong><br>
                        <small class="text-muted">
                            From: ${part.fromLocationName || 'Unknown'} → To: ${part.toLocationName || 'Unknown'}<br>
                            Date: ${formatDate(part.movementDate)}
                        </small>
                    </div>`;
                }).join('<hr class="my-1"/>');
            }
        }

        // Async Data Loading for RMA List
        const AsyncRMALoader = {
            init() {
                const loadingContainer = document.getElementById('rma-loading-container');
                if (!loadingContainer) return;

                this.loadRMAData();
            },

            loadRMAData() {
                const progressBar = document.getElementById('rma-loading-progress');
                const loadingContainer = document.getElementById('rma-loading-container');
                const tableContainer = document.getElementById('rma-table-container');

                this.updateProgress(10);

                fetch('/rma/api/data')
                    .then(response => {
                        this.updateProgress(30);
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        this.updateProgress(60);
                        if (data.success) {
                            this.populateTable(data);
                            this.updateProgress(90);
                            
                            setTimeout(() => {
                                this.updateProgress(100);
                                
                                setTimeout(() => {
                                    loadingContainer.style.display = 'none';
                                    tableContainer.style.display = 'block';
                                    
                                    // Initialize RMA Manager after loading data
                                    try {
                                        window.rmaManager = new RMAManager();
                                        // Recalculate counts after async data load
                                        window.rmaManager.calculateTotalPriorityCounts();
                                        window.rmaManager.updatePriorityCounts();
                                        window.rmaManager.applyDefaultSort();
                                        // Bootstrap dropdowns are initialized globally
                                        window.rmaManager.initializeInteractions();
                                    } catch (error) {
                                        console.error('Error initializing RMAManager:', error);
                                    }
                                }, 200);
                            }, 300);
                        } else {
                            this.showError(data.error || 'Failed to load RMA data');
                        }
                    })
                    .catch(error => {
                        console.error('Error loading RMA data:', error);
                        this.showError('Failed to load RMA data. Please refresh the page.');
                    });
            },

            updateProgress(percent) {
                const progressBar = document.getElementById('rma-loading-progress');
                if (progressBar) {
                    progressBar.style.width = percent + '%';
                    progressBar.setAttribute('aria-valuenow', percent);
                }
            },

            showError(message) {
                const loadingContainer = document.getElementById('rma-loading-container');
                if (loadingContainer) {
                    loadingContainer.innerHTML = `
                        <div class="alert alert-danger" role="alert">
                            <i class="fas fa-exclamation-triangle me-2"></i>
                            ${message}
                            <br><br>
                            <button class="btn btn-primary" onclick="location.reload()">Retry</button>
                        </div>
                    `;
                }
            },

            populateTable(data) {
                const tbody = document.querySelector('#rma-table tbody');
                if (!tbody) return;

                tbody.innerHTML = '';

                // Store moving parts data globally for tooltip access
                window.rmaMovingPartsData = data.movingPartsMap || {};

                data.rmas.forEach(rma => {
                    const row = this.createTableRow(rma, data.rmaCommentsMap, data.movingPartsMap);
                    tbody.appendChild(row);
                });

                this.updateCounts(data.rmas.length);
            },

            createTableRow(rma, commentsMap, movingPartsMap) {
                const row = document.createElement('tr');
                row.className = 'data-table-row rma-row';
                row.setAttribute('data-rma-id', rma.id); // Add RMA ID for click handler
                row.setAttribute('data-tool', rma.tool?.name?.toLowerCase() || '');
                row.setAttribute('data-parts', this.formatPartsForSearch(rma.partLineItems));
                row.setAttribute('data-part-numbers', this.formatPartNumbersForSearch(rma.partLineItems));
                row.setAttribute('data-rma-number', (rma.rmaNumber || rma.sapNotificationNumber || '').toLowerCase());
                row.setAttribute('data-status', rma.status || '');
                row.setAttribute('data-priority', rma.priority || 'MEDIUM');
                
                // Add date attributes for sorting (in ISO format for proper date comparison)
                row.setAttribute('data-written-date', rma.writtenDate || '');
                row.setAttribute('data-rma-provided-date', rma.rmaNumberProvidedDate || '');
                row.setAttribute('data-shipping-memo-date', rma.shippingMemoEmailedDate || '');
                row.setAttribute('data-parts-received-date', rma.partsReceivedDate || '');
                row.setAttribute('data-parts-installed-date', rma.installedPartsDate || '');
                row.setAttribute('data-failed-parts-ready-date', rma.failedPartsPackedDate || '');
                row.setAttribute('data-failed-parts-shipped-date', rma.failedPartsShippedDate || '');
                
                const formatDate = (dateStr) => {
                    if (!dateStr) return '-';
                    const date = new Date(dateStr);
                    return date.toLocaleDateString('en-US', { month: '2-digit', day: '2-digit', year: '2-digit' });
                };

                const getStatusBadgeClass = (status) => {
                    const statusMap = {
                        'RMA_WRITTEN_EMAILED': 'bg-primary',
                        'NUMBER_PROVIDED': 'bg-info',
                        'MEMO_EMAILED': 'bg-secondary',
                        'RECEIVED_PARTS': 'bg-warning text-dark',
                        'WAITING_CUSTOMER': 'bg-danger',
                        'WAITING_FSE': 'bg-danger',
                        'COMPLETED': 'bg-success'
                    };
                    return statusMap[status] || 'bg-light text-dark';
                };

                const getPriorityBadgeClass = (priority) => {
                    const priorityMap = {
                        'LOW': 'bg-success',
                        'MEDIUM': 'bg-primary',
                        'HIGH': 'bg-warning text-dark',
                        'URGENT': 'bg-danger'
                    };
                    return priorityMap[priority] || 'bg-primary';
                };

                const formatParts = (partLineItems) => {
                    if (!partLineItems || partLineItems.length === 0) return 'N/A';
                    return `<ul class="list-unstyled mb-0" style="font-size: 0.9em;">
                        ${partLineItems.map(item => 
                            `<li>${item.partName || item.partNumber || item.productDescription || 'Unknown Part'}</li>`
                        ).join('')}
                    </ul>`;
                };

                const formatComments = (comments) => {
                    if (!comments || comments.length === 0) return '';
                    return comments.map(comment => {
                        const date = comment.createdDate ? new Date(comment.createdDate).toLocaleDateString() : '';
                        const user = comment.user?.name || 'Unknown';
                        return `<div class="mb-2"><small class="text-muted">${date} by ${user}</small><br/>${comment.content || 'No content'}</div>`;
                    }).join('<hr class="my-1"/>');
                };

                const commentCount = commentsMap[rma.id] || 0;
                const movingPartData = movingPartsMap[rma.id] || [];
                const movingPartCount = Array.isArray(movingPartData) ? movingPartData.length : 0;

                row.innerHTML = `
                    <td>
                        <span class="rma-number">
                            ${rma.rmaNumber || rma.sapNotificationNumber || `RMA-${rma.id}`}
                        </span>

                        <i class="bi bi-info-circle-fill problem-popover-icon ms-1"
                           data-rma-id="${rma.id}"
                           data-rma-number="${rma.rmaNumber || rma.sapNotificationNumber || 'RMA-' + rma.id}"
                           data-bs-toggle="popover"
                           data-bs-placement="right"
                           data-bs-trigger="hover focus click"
                           data-bs-html="true"
                           data-bs-title="Problem Details for ${rma.rmaNumber || rma.sapNotificationNumber || 'RMA-' + rma.id}"
                           data-bs-content="Loading problem details..."
                           title="Hover to load problem details"></i>
                    </td>
                    <td>${rma.tool ? `<a href="/tools/${rma.tool.id}" class="text-decoration-hover-underline">${rma.tool.name}</a> <i class="bi bi-info-circle-fill ms-1 tool-tooltip" data-rma-id="${rma.id}" data-tool-name="${rma.tool.name}" data-bs-toggle="popover" data-bs-placement="right" data-bs-trigger="hover focus click" data-bs-html="true" data-bs-title="${rma.tool.name}" data-bs-content="Loading tool details..." title="Hover to load tool details"></i>` : '-'}</td>
                    <td class="allow-wrap">${formatParts(rma.partLineItems)}</td>
                    <td class="text-center">
                        <span class="badge rounded-pill status-badge ${getStatusBadgeClass(rma.status)}">
                            ${rma.statusDisplayName || 'N/A'}
                        </span>
                    </td>
                    <td class="text-center">
                        <span class="badge rounded-pill priority-badge ${getPriorityBadgeClass(rma.priority)}">
                            ${rma.priorityDisplayName || 'Medium'}
                        </span>
                    </td>
                    <td>${formatDate(rma.writtenDate)}</td>
                    <td>${formatDate(rma.rmaNumberProvidedDate)}</td>
                    <td>${formatDate(rma.shippingMemoEmailedDate)}</td>
                    <td>${formatDate(rma.partsReceivedDate)}</td>
                    <td>${formatDate(rma.installedPartsDate)}</td>
                    <td>${formatDate(rma.failedPartsPackedDate)}</td>
                    <td>${formatDate(rma.failedPartsShippedDate)}</td>
                    <td class="text-center">
                        ${movingPartCount > 0 ? `
                            <i class="bi bi-arrow-left-right moving-parts-icon info-icon-interactive"
                               data-rma-id="${rma.id}"
                               data-moving-part-count="${movingPartCount}"
                               data-bs-toggle="popover"
                               data-bs-placement="left"
                               data-bs-trigger="hover focus click"
                               data-bs-html="true"
                               data-bs-title="Moving Parts (${movingPartCount})"
                               data-bs-content="Loading moving parts..."
                               title="Hover to load moving parts"></i>
                        ` : `
                            <i class="bi bi-arrow-left-right text-muted"></i>
                        `}
                    </td>
                    <td class="text-center">
                        <i class="bi bi-chat-dots-fill comment-icon ${commentCount > 0 ? 'info-icon-interactive' : 'text-muted'}"
                           data-rma-id="${rma.id}"
                           data-comment-count="${commentCount}"
                           ${commentCount > 0 ? 'data-bs-toggle="popover"' : ''}
                           data-bs-placement="left"
                           data-bs-trigger="hover focus click"
                           data-bs-html="true"
                           data-bs-title="Comments (${commentCount})"
                           data-bs-content="Loading comments..."
                           ${commentCount > 0 ? 'title="Hover to load comments"' : ''}></i>
                        <span class="ms-1 small">${commentCount}</span>
                    </td>
                `;

                return row;
            },

            formatPartsForSearch(partLineItems) {
                if (!partLineItems || partLineItems.length === 0) return '';
                return partLineItems.map(item => 
                    [item.partName, item.productDescription].filter(Boolean).join(' ')
                ).join(' ').toLowerCase();
            },

            formatPartNumbersForSearch(partLineItems) {
                if (!partLineItems || partLineItems.length === 0) return '';
                return partLineItems.map(item => item.partNumber || '').filter(Boolean).join(' ').toLowerCase();
            },



            hasProblemDetails(rma) {
                return rma.problemDiscoverer || rma.problemDiscoveryDate || rma.whatHappened || 
                       rma.whyAndHowItHappened || rma.howContained || rma.whoContained;
            },

            formatProblemDetails(rma) {
                const formatDate = (dateStr) => {
                    if (!dateStr) return '-';
                    try {
                        const date = new Date(dateStr);
                        return date.toLocaleDateString('en-US', { month: '2-digit', day: '2-digit', year: '2-digit' });
                    } catch {
                        return '-';
                    }
                };

                return `<strong>Who:</strong> ${rma.problemDiscoverer || '-'}<br>` +
                       `<strong>When:</strong> ${formatDate(rma.problemDiscoveryDate)}<br>` +
                       `<strong>What:</strong> ${rma.whatHappened || '-'}<br>` +
                       `<strong>Why:</strong> ${rma.whyAndHowItHappened || '-'}<br>` +
                       `<strong>How:</strong> ${rma.howContained || '-'}<br>` +
                       `<strong>By:</strong> ${rma.whoContained || '-'}`;
            },

            updateCounts(rmaCount) {
                const countElement = document.getElementById('rma-count');
                const countTextElement = document.getElementById('rma-count-text');
                
                if (countElement) countElement.textContent = rmaCount;
                if (countTextElement) countTextElement.textContent = rmaCount === 1 ? 'RMA' : 'RMAs';
            },

            initializeInteractions() {
                // Re-initialize popovers for dynamically loaded content
                const popoverTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="popover"]'));
                popoverTriggerList.map(function (popoverTriggerEl) {
                    return new bootstrap.Popover(popoverTriggerEl, {
                        sanitize: false,
                        fallbackPlacements: ['left', 'top', 'bottom'],
                        container: 'body'
                    });
                });

                // Add click handlers for closing popovers
                document.addEventListener('click', function (event) {
                    const popovers = document.querySelectorAll('.popover');
                    popovers.forEach(function (popover) {
                        const trigger = document.querySelector(`[aria-describedby="${popover.id}"]`);
                        if (trigger && !trigger.contains(event.target) && !popover.contains(event.target)) {
                            const instance = bootstrap.Popover.getInstance(trigger);
                            if (instance) instance.hide();
                        }
                    });
                });
                
                // Initialize lazy loading for comments, problem details, tool details, and moving parts
                this.initLazyCommentLoading();
                this.initLazyProblemDetailsLoading();
                this.initLazyToolDetailsLoading();
                this.initLazyMovingPartsLoading();
                
                // Initialize clickable table rows
                initializeClickableRows();
            },
            
            initLazyCommentLoading() {
                const self = this; // Capture 'this' reference
                const commentIcons = document.querySelectorAll('.comment-icon');
                console.log(`Found ${commentIcons.length} comment icons`);
                
                commentIcons.forEach(icon => {
                    const rmaId = icon.getAttribute('data-rma-id');
                    if (!rmaId) return;
                    
                    // Check comment count first - don't initialize popover for 0 comments
                    const commentCount = parseInt(icon.getAttribute('data-comment-count') || '0');
                    if (commentCount === 0) {
                        return; // Skip initialization entirely for 0 comments
                    }
                    
                    // Get or create cache entry for this RMA
                    if (!self.tooltipCache.comments.has(rmaId)) {
                        self.tooltipCache.comments.set(rmaId, {
                            data: null,
                            isLoaded: false,
                            isLoading: false,
                            currentRequest: null
                        });
                    }
                    
                    const cacheEntry = self.tooltipCache.comments.get(rmaId);
                    
                    // Ensure popover is initialized with the original content
                    const popover = bootstrap.Popover.getInstance(icon);
                    if (!popover) {
                        new bootstrap.Popover(icon, {
                            html: true,
                            placement: 'left',
                            trigger: 'hover focus click',
                            title: icon.getAttribute('data-bs-title') || 'Comments',
                            content: icon.getAttribute('data-bs-content') || 'Loading comments...',
                            sanitize: false,
                            fallbackPlacements: ['left', 'top', 'bottom'],
                            container: 'body'
                        });
                    }
                    
                    icon.addEventListener('mouseenter', async () => {
                        const commentCount = parseInt(icon.getAttribute('data-comment-count') || '0');
                        
                        // Don't load if no comments
                        if (commentCount === 0) return;
                        
                        // If already loaded, show cached data immediately
                        if (cacheEntry.isLoaded && cacheEntry.data) {
                            console.log(`Using cached comments for RMA ${rmaId}`);
                            const formattedComments = self.formatCommentsForPopover(cacheEntry.data.comments);
                            
                            // Always dispose and recreate popover to ensure fresh content
                            const currentPopover = bootstrap.Popover.getInstance(icon);
                            if (currentPopover) {
                                currentPopover.dispose();
                            }
                            
                            // Create new popover with cached content and show it immediately
                            const newPopover = new bootstrap.Popover(icon, {
                                html: true,
                                placement: 'left',
                                trigger: 'hover focus click',
                                title: `Comments (${cacheEntry.data.count})`,
                                content: formattedComments,
                                sanitize: false,
                                fallbackPlacements: ['left', 'top', 'bottom'],
                                container: 'body'
                            });
                            newPopover.show();
                            return;
                        }
                        
                        // Cancel any existing request
                        if (cacheEntry.currentRequest && !cacheEntry.currentRequest.signal.aborted) {
                            cacheEntry.currentRequest.abort();
                            cacheEntry.isLoading = false; // Reset loading state when we abort
                        }
                        
                        // Don't start new request if already loading
                        if (cacheEntry.isLoading) {
                            return;
                        }
                        
                        // Create new AbortController for this request
                        const abortController = new AbortController();
                        cacheEntry.currentRequest = abortController;
                        cacheEntry.isLoading = true;
                        
                        try {
                            console.log(`Loading comments for RMA ${rmaId} (cache miss)`);
                            const response = await fetch(`/rma/api/rma/${rmaId}/comments`, {
                                signal: abortController.signal
                            });
                            console.log('Response status:', response.status);
                            
                            if (!response.ok) {
                                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                            }
                            
                            const data = await response.json();
                            console.log('Response data:', data);
                            
                            if (data.success && data.comments) {
                                // Cache the data
                                cacheEntry.data = data;
                                cacheEntry.isLoaded = true;
                                
                                const formattedComments = self.formatCommentsForPopover(data.comments);
                                
                                // Update the existing popover's content
                                const currentPopover = bootstrap.Popover.getInstance(icon);
                                if (currentPopover) {
                                    // Update the popover's tip content if it's already shown
                                    const popoverTip = currentPopover.tip;
                                    if (popoverTip) {
                                        const popoverBody = popoverTip.querySelector('.popover-body');
                                        if (popoverBody) {
                                            popoverBody.innerHTML = formattedComments;
                                        }
                                        const popoverHeader = popoverTip.querySelector('.popover-header');
                                        if (popoverHeader) {
                                            popoverHeader.textContent = `Comments (${data.count})`;
                                        }
                                    }
                                    
                                    // Also update the data attributes for future shows
                                    icon.setAttribute('data-bs-content', formattedComments);
                                    icon.setAttribute('data-bs-title', `Comments (${data.count})`);
                                }
                            } else {
                                console.error('Failed to load comments:', data.error);
                                const currentPopover = bootstrap.Popover.getInstance(icon);
                                if (currentPopover) {
                                    const popoverTip = currentPopover.tip;
                                    if (popoverTip) {
                                        const popoverBody = popoverTip.querySelector('.popover-body');
                                        if (popoverBody) {
                                            popoverBody.innerHTML = 'Error loading comments';
                                        }
                                    }
                                    icon.setAttribute('data-bs-content', 'Error loading comments');
                                }
                            }
                        } catch (error) {
                            // Don't show error if request was aborted (user moved mouse away quickly)
                            if (error.name === 'AbortError') {
                                console.log('Request aborted for comments loading');
                                return;
                            }
                            
                            console.error('Error loading comments:', error);
                            const currentPopover = bootstrap.Popover.getInstance(icon);
                            if (currentPopover) {
                                const popoverTip = currentPopover.tip;
                                if (popoverTip) {
                                    const popoverBody = popoverTip.querySelector('.popover-body');
                                    if (popoverBody) {
                                        popoverBody.innerHTML = 'Error loading comments';
                                    }
                                }
                                icon.setAttribute('data-bs-content', 'Error loading comments');
                            }
                        } finally {
                            // Only reset loading state if this request wasn't aborted
                            if (!abortController.signal.aborted) {
                                cacheEntry.isLoading = false;
                            }
                        }
                    });
                });
            },
            
            formatCommentsForPopover(comments) {
                if (!comments || comments.length === 0) {
                    return 'No comments available';
                }
                
                return comments.map(comment => {
                    const formatDate = (dateStr) => {
                        if (!dateStr) return 'Unknown date';
                        try {
                            const date = new Date(dateStr);
                            return date.toLocaleDateString('en-US', { 
                                month: '2-digit', 
                                day: '2-digit', 
                                year: '2-digit',
                                hour: '2-digit',
                                minute: '2-digit'
                            });
                        } catch {
                            return 'Unknown date';
                        }
                    };
                    
                    return `<div class="mb-2">
                        <small class="text-muted">${formatDate(comment.createdDate)} by ${comment.author || 'Unknown'}</small><br/>
                        <span>${comment.content || 'No content'}</span>
                    </div>`;
                }).join('<hr class="my-1"/>');
            },
            
            initLazyProblemDetailsLoading() {
                const self = this; // Capture 'this' reference
                const problemIcons = document.querySelectorAll('.problem-popover-icon');
                console.log(`Found ${problemIcons.length} problem detail icons`);
                
                problemIcons.forEach(icon => {
                    const rmaId = icon.getAttribute('data-rma-id');
                    if (!rmaId) return;
                    
                    // Get or create cache entry for this RMA
                    if (!self.tooltipCache.problemDetails.has(rmaId)) {

                        self.tooltipCache.problemDetails.set(rmaId, {
                            data: null,
                            isLoaded: false,
                            isLoading: false,
                            currentRequest: null
                        });
                    }
                    
                    const cacheEntry = self.tooltipCache.problemDetails.get(rmaId);
                    
                    // Ensure popover is initialized with the original content
                    const popover = bootstrap.Popover.getInstance(icon);
                    if (!popover) {
                        new bootstrap.Popover(icon, {
                            html: true,
                            placement: 'right',
                            trigger: 'hover focus click',
                            title: icon.getAttribute('data-bs-title') || 'Problem Details',
                            content: icon.getAttribute('data-bs-content') || 'Loading problem details...',
                            sanitize: false,
                            fallbackPlacements: ['right', 'top', 'bottom'],
                            container: 'body'
                        });
                    }
                    
                    icon.addEventListener('mouseenter', async () => {
                        // If already loaded, show cached data immediately
                        if (cacheEntry.isLoaded && cacheEntry.data) {
                            console.log(`Using cached problem details for RMA ${rmaId}`);
                            const formattedDetails = self.formatProblemDetailsForPopover(cacheEntry.data.problemDetails);
                            icon.setAttribute('data-bs-content', formattedDetails);
                            
                            // Always dispose and recreate popover to ensure fresh content
                            const currentPopover = bootstrap.Popover.getInstance(icon);
                            if (currentPopover) {
                                currentPopover.dispose();
                            }
                            
                            // Create new popover with cached content and show it immediately
                            const newPopover = new bootstrap.Popover(icon, {
                                html: true,
                                placement: 'right',
                                trigger: 'hover focus click',
                                title: icon.getAttribute('data-bs-title') || 'Problem Details',
                                content: formattedDetails,
                                sanitize: false,
                                fallbackPlacements: ['left', 'top', 'bottom'],
                                container: 'body'
                            });
                            newPopover.show();
                            return;
                        }
                        
                        // Cancel any existing request
                        if (cacheEntry.currentRequest && !cacheEntry.currentRequest.signal.aborted) {
                            cacheEntry.currentRequest.abort();
                            cacheEntry.isLoading = false; // Reset loading state when we abort
                        }
                        
                        // Don't start new request if already loading
                        if (cacheEntry.isLoading) {
                            return;
                        }
                        
                        // Create new AbortController for this request
                        const abortController = new AbortController();
                        cacheEntry.currentRequest = abortController;
                        cacheEntry.isLoading = true;
                        
                        try {
                            console.log(`Loading problem details for RMA ${rmaId} (cache miss)`);
                            const response = await fetch(`/rma/${rmaId}/problem-details`, {
                                signal: abortController.signal
                            });
                            console.log('Response status:', response.status);
                            
                            if (!response.ok) {
                                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                            }
                            
                            const data = await response.json();
                            console.log('Response data:', data);
                            
                            if (data.success && data.problemDetails) {
                                // Cache the data
                                cacheEntry.data = data;
                                cacheEntry.isLoaded = true;
                                
                                const formattedDetails = self.formatProblemDetailsForPopover(data.problemDetails);
                                
                                // Update the data attributes first
                                icon.setAttribute('data-bs-content', formattedDetails);
                                
                                // Update the existing popover's content
                                const currentPopover = bootstrap.Popover.getInstance(icon);
                                if (currentPopover) {
                                    // Check if popover is currently visible
                                    const popoverTip = currentPopover.tip;
                                    if (popoverTip && document.body.contains(popoverTip)) {
                                        // Popover is visible, update content and refresh
                                        const popoverBody = popoverTip.querySelector('.popover-body');
                                        if (popoverBody) {
                                            popoverBody.innerHTML = formattedDetails;
                                        }
                                    } else {
                                        // Popover is not visible, dispose and recreate to ensure fresh content
                                        currentPopover.dispose();
                                        new bootstrap.Popover(icon, {
                                            html: true,
                                            placement: 'right',
                                            trigger: 'hover focus click',
                                            title: icon.getAttribute('data-bs-title') || 'Problem Details',
                                            content: formattedDetails,
                                            sanitize: false,
                                            fallbackPlacements: ['left', 'top', 'bottom'],
                                            container: 'body'
                                        });
                                    }
                                }
                            } else {
                                console.error('Failed to load problem details:', data.error);
                                const errorMessage = data.hasDetails === false ? 'No problem details available' : 'Error loading problem details';
                                
                                // Update the data attributes first
                                icon.setAttribute('data-bs-content', errorMessage);
                                
                                const currentPopover = bootstrap.Popover.getInstance(icon);
                                if (currentPopover) {
                                    const popoverTip = currentPopover.tip;
                                    if (popoverTip && document.body.contains(popoverTip)) {
                                        const popoverBody = popoverTip.querySelector('.popover-body');
                                        if (popoverBody) {
                                            popoverBody.innerHTML = errorMessage;
                                        }
                                    } else {
                                        // Recreate popover with error message
                                        currentPopover.dispose();
                                        new bootstrap.Popover(icon, {
                                            html: true,
                                            placement: 'right',
                                            trigger: 'hover focus click',
                                            title: icon.getAttribute('data-bs-title') || 'Problem Details',
                                            content: errorMessage,
                                            sanitize: false,
                                            fallbackPlacements: ['left', 'top', 'bottom'],
                                            container: 'body'
                                        });
                                    }
                                }
                            }
                        } catch (error) {
                            // Don't show error if request was aborted (user moved mouse away quickly)
                            if (error.name === 'AbortError') {
                                console.log('Request aborted for problem details loading');
                                return;
                            }
                            
                            console.error('Error loading problem details:', error);
                            const errorMessage = 'Error loading problem details';
                            
                            // Update the data attributes first
                            icon.setAttribute('data-bs-content', errorMessage);
                            
                            const currentPopover = bootstrap.Popover.getInstance(icon);
                            if (currentPopover) {
                                const popoverTip = currentPopover.tip;
                                if (popoverTip && document.body.contains(popoverTip)) {
                                    const popoverBody = popoverTip.querySelector('.popover-body');
                                    if (popoverBody) {
                                        popoverBody.innerHTML = errorMessage;
                                    }
                                } else {
                                    // Recreate popover with error message
                                    currentPopover.dispose();
                                    new bootstrap.Popover(icon, {
                                        html: true,
                                        placement: 'right',
                                        trigger: 'hover focus click',
                                        title: icon.getAttribute('data-bs-title') || 'Problem Details',
                                        content: errorMessage,
                                        sanitize: false,
                                        fallbackPlacements: ['left', 'top', 'bottom'],
                                        container: 'body'
                                    });
                                }
                            }
                        } finally {
                            // Only reset loading state if this request wasn't aborted
                            if (!abortController.signal.aborted) {
                                cacheEntry.isLoading = false;
                            }
                        }
                    });
                });
            },
            
            formatProblemDetailsForPopover(problemDetails) {
                const formatDate = (dateStr) => {
                    if (!dateStr) return '-';
                    try {
                        const date = new Date(dateStr);
                        return date.toLocaleDateString('en-US', { month: '2-digit', day: '2-digit', year: '2-digit' });
                    } catch {
                        return '-';
                    }
                };

                return `<strong>Who:</strong> ${problemDetails.problemDiscoverer || '-'}<br>` +
                       `<strong>When:</strong> ${formatDate(problemDetails.problemDiscoveryDate)}<br>` +
                       `<strong>What:</strong> ${problemDetails.whatHappened || '-'}<br>` +
                       `<strong>Why:</strong> ${problemDetails.whyAndHowItHappened || '-'}<br>` +
                       `<strong>How:</strong> ${problemDetails.howContained || '-'}<br>` +
                       `<strong>By:</strong> ${problemDetails.whoContained || '-'}`;
            },

            initLazyToolDetailsLoading() {
                const self = this; // Capture 'this' reference
                const toolIcons = document.querySelectorAll('.tool-tooltip');
                console.log(`Found ${toolIcons.length} tool detail icons`);
                
                toolIcons.forEach(icon => {
                    const rmaId = icon.getAttribute('data-rma-id');
                    if (!rmaId) return;
                    
                    // Get or create cache entry for this RMA
                    if (!self.tooltipCache.toolDetails.has(rmaId)) {
                        self.tooltipCache.toolDetails.set(rmaId, {
                            data: null,
                            isLoaded: false,
                            isLoading: false,
                            currentRequest: null
                        });
                    }
                    
                    const cacheEntry = self.tooltipCache.toolDetails.get(rmaId);
                    
                    // Ensure popover is initialized with the original content
                    const popover = bootstrap.Popover.getInstance(icon);
                    if (!popover) {
                        new bootstrap.Popover(icon, {
                            html: true,
                            placement: 'right',
                            trigger: 'hover focus click',
                            title: icon.getAttribute('data-bs-title') || 'Tool Details',
                            content: icon.getAttribute('data-bs-content') || 'Loading tool details...',
                            sanitize: false,
                            fallbackPlacements: ['left', 'top', 'bottom'],
                            container: 'body'
                        });
                    }
                    
                    icon.addEventListener('mouseenter', async () => {
                        // If already loaded, show cached data immediately
                        if (cacheEntry.isLoaded && cacheEntry.data) {
                            console.log(`Using cached tool details for RMA ${rmaId}`);
                            const formattedDetails = self.formatToolDetailsForPopover(cacheEntry.data.toolDetails);
                            icon.setAttribute('data-bs-content', formattedDetails);
                            
                            // Update popover if currently visible
                            const currentPopover = bootstrap.Popover.getInstance(icon);
                            if (currentPopover) {
                                const popoverTip = currentPopover.tip;
                                if (popoverTip && document.body.contains(popoverTip)) {
                                    const popoverBody = popoverTip.querySelector('.popover-body');
                                    if (popoverBody) {
                                        popoverBody.innerHTML = formattedDetails;
                                    }
                                }
                            }
                            return;
                        }
                        
                        // Cancel any existing request
                        if (cacheEntry.currentRequest && !cacheEntry.currentRequest.signal.aborted) {
                            cacheEntry.currentRequest.abort();
                            cacheEntry.isLoading = false; // Reset loading state when we abort
                        }
                        
                        // Don't start new request if already loading
                        if (cacheEntry.isLoading) {
                            return;
                        }
                        
                        // Create new AbortController for this request
                        const abortController = new AbortController();
                        cacheEntry.currentRequest = abortController;
                        cacheEntry.isLoading = true;
                        
                        try {
                            console.log(`Loading tool details for RMA ${rmaId} (cache miss)`);
                            const response = await fetch(`/rma/api/rma/${rmaId}/tool-details`, {
                                signal: abortController.signal
                            });
                            console.log('Tool details response status:', response.status);
                            
                            if (!response.ok) {
                                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                            }
                            
                            const data = await response.json();
                            console.log('Tool details response data:', data);
                            
                            if (data.success && data.hasTool && data.toolDetails) {
                                // Cache the data
                                cacheEntry.data = data;
                                cacheEntry.isLoaded = true;
                                
                                const formattedToolDetails = self.formatToolDetailsForPopover(data.toolDetails);
                                
                                // Update the data attributes first
                                icon.setAttribute('data-bs-content', formattedToolDetails);
                                
                                // Update the existing popover's content
                                const currentPopover = bootstrap.Popover.getInstance(icon);
                                if (currentPopover) {
                                    // Check if popover is currently visible
                                    const popoverTip = currentPopover.tip;
                                    if (popoverTip && document.body.contains(popoverTip)) {
                                        // Popover is visible, update content
                                        const popoverBody = popoverTip.querySelector('.popover-body');
                                        if (popoverBody) {
                                            popoverBody.innerHTML = formattedToolDetails;
                                        }
                                    } else {
                                        // Popover is not visible, dispose and recreate
                                        currentPopover.dispose();
                                        new bootstrap.Popover(icon, {
                                            html: true,
                                            placement: 'right',
                                            trigger: 'hover focus click',
                                            title: icon.getAttribute('data-bs-title') || 'Tool Details',
                                            content: formattedToolDetails,
                                            sanitize: false,
                                            fallbackPlacements: ['left', 'top', 'bottom'],
                                            container: 'body'
                                        });
                                    }
                                }
                            } else if (data.success && !data.hasTool) {
                                const noToolMessage = 'No tool assigned to this RMA';
                                
                                // Update the data attributes first
                                icon.setAttribute('data-bs-content', noToolMessage);
                                
                                const currentPopover = bootstrap.Popover.getInstance(icon);
                                if (currentPopover) {
                                    const popoverTip = currentPopover.tip;
                                    if (popoverTip && document.body.contains(popoverTip)) {
                                        const popoverBody = popoverTip.querySelector('.popover-body');
                                        if (popoverBody) {
                                            popoverBody.innerHTML = noToolMessage;
                                        }
                                    } else {
                                        // Recreate popover
                                        currentPopover.dispose();
                                        new bootstrap.Popover(icon, {
                                            html: true,
                                            placement: 'right',
                                            trigger: 'hover focus click',
                                            title: icon.getAttribute('data-bs-title') || 'Tool Details',
                                            content: noToolMessage,
                                            sanitize: false,
                                            fallbackPlacements: ['left', 'top', 'bottom'],
                                            container: 'body'
                                        });
                                    }
                                }
                            } else {
                                console.error('Failed to load tool details:', data.error);
                                const errorMessage = 'Error loading tool details';
                                
                                // Update the data attributes first
                                icon.setAttribute('data-bs-content', errorMessage);
                                
                                const currentPopover = bootstrap.Popover.getInstance(icon);
                                if (currentPopover) {
                                    const popoverTip = currentPopover.tip;
                                    if (popoverTip && document.body.contains(popoverTip)) {
                                        const popoverBody = popoverTip.querySelector('.popover-body');
                                        if (popoverBody) {
                                            popoverBody.innerHTML = errorMessage;
                                        }
                                    } else {
                                        // Recreate popover with error message
                                        currentPopover.dispose();
                                        new bootstrap.Popover(icon, {
                                            html: true,
                                            placement: 'right',
                                            trigger: 'hover focus click',
                                            title: icon.getAttribute('data-bs-title') || 'Tool Details',
                                            content: errorMessage,
                                            sanitize: false,
                                            fallbackPlacements: ['left', 'top', 'bottom'],
                                            container: 'body'
                                        });
                                    }
                                }
                            }
                        } catch (error) {
                            // Don't show error if request was aborted (user moved mouse away quickly)
                            if (error.name === 'AbortError') {
                                console.log('Request aborted for tool details loading');
                                return;
                            }
                            
                            console.error('Error loading tool details:', error);
                            const errorMessage = 'Error loading tool details';
                            
                            // Update the data attributes first
                            icon.setAttribute('data-bs-content', errorMessage);
                            
                            const currentPopover = bootstrap.Popover.getInstance(icon);
                            if (currentPopover) {
                                const popoverTip = currentPopover.tip;
                                if (popoverTip && document.body.contains(popoverTip)) {
                                    const popoverBody = popoverTip.querySelector('.popover-body');
                                    if (popoverBody) {
                                        popoverBody.innerHTML = errorMessage;
                                    }
                                } else {
                                    // Recreate popover with error message
                                    currentPopover.dispose();
                                    new bootstrap.Popover(icon, {
                                        html: true,
                                        placement: 'right',
                                        trigger: 'hover focus click',
                                        title: icon.getAttribute('data-bs-title') || 'Tool Details',
                                        content: errorMessage,
                                        sanitize: false,
                                        fallbackPlacements: ['left', 'top', 'bottom'],
                                        container: 'body'
                                    });
                                }
                            }
                        } finally {
                            // Only reset loading state if this request wasn't aborted
                            if (!abortController.signal.aborted) {
                                cacheEntry.isLoading = false;
                            }
                        }
                    });
                });
            },
            
            formatToolDetailsForPopover(toolDetails) {
                let result = `<strong>Type:</strong> ${toolDetails.toolType || 'Unknown Type'}<br>`;
                
                // Handle model display
                const models = [toolDetails.model1, toolDetails.model2].filter(Boolean);
                if (models.length > 0) {
                    result += `<strong>Model:</strong> ${models.join('/')}<br>`;
                }
                
                // Handle serial number display
                const serials = [toolDetails.serialNumber1, toolDetails.serialNumber2].filter(Boolean);
                if (serials.length > 0) {
                    result += `<strong>Serial:</strong> ${serials.join('/')}`;
                }
                
                return result;
            },

            initLazyMovingPartsLoading() {
                const self = this; // Capture 'this' reference
                const movingPartsIcons = document.querySelectorAll('.moving-parts-icon');
                console.log(`Found ${movingPartsIcons.length} moving parts icons`);
                
                movingPartsIcons.forEach(icon => {
                    const rmaId = icon.getAttribute('data-rma-id');
                    if (!rmaId) return;
                    
                    // Get or create cache entry for this RMA
                    if (!self.tooltipCache.movingParts.has(rmaId)) {
                        self.tooltipCache.movingParts.set(rmaId, {
                            data: null,
                            isLoaded: false,
                            isLoading: false,
                            currentRequest: null
                        });
                    }
                    
                    const cacheEntry = self.tooltipCache.movingParts.get(rmaId);
                    
                    // Initialize popover if not already done
                    let popover = bootstrap.Popover.getInstance(icon);
                    if (!popover) {
                        popover = new bootstrap.Popover(icon, {
                            html: true,
                            placement: 'left',
                            trigger: 'hover focus click',
                            title: icon.getAttribute('data-bs-title') || 'Moving Parts',
                            content: icon.getAttribute('data-bs-content') || 'Loading moving parts...',
                            sanitize: false,
                            fallbackPlacements: ['right', 'top', 'bottom'],
                            container: 'body'
                        });
                    }
                    
                    icon.addEventListener('mouseenter', async () => {
                        // If already loaded, show cached data immediately
                        if (cacheEntry.isLoaded && cacheEntry.data) {
                            console.log(`Using cached moving parts for RMA ${rmaId}`);
                            const formattedMovingParts = self.formatMovingPartsForPopover(cacheEntry.data.movingParts);
                            
                            // Always dispose and recreate popover to ensure fresh content
                            const currentPopover = bootstrap.Popover.getInstance(icon);
                            if (currentPopover) {
                                currentPopover.dispose();
                            }
                            
                            // Create new popover with cached content and show it immediately
                            const newPopover = new bootstrap.Popover(icon, {
                                html: true,
                                placement: 'left',
                                trigger: 'hover focus click',
                                title: `Moving Parts (${cacheEntry.data.movingParts.length})`,
                                content: formattedMovingParts,
                                sanitize: false,
                                fallbackPlacements: ['right', 'top', 'bottom'],
                                container: 'body'
                            });
                            newPopover.show();
                            return;
                        }
                        
                        // Cancel any existing request
                        if (cacheEntry.currentRequest && !cacheEntry.currentRequest.signal.aborted) {
                            cacheEntry.currentRequest.abort();
                            cacheEntry.isLoading = false; // Reset loading state when we abort
                        }
                        
                        // Don't start new request if already loading
                        if (cacheEntry.isLoading) {
                            return;
                        }
                        
                        // Create new AbortController for this request
                        const abortController = new AbortController();
                        cacheEntry.currentRequest = abortController;
                        cacheEntry.isLoading = true;
                        
                        try {
                            console.log(`Using server-side moving parts data for RMA ${rmaId}`);
                            
                            // Get moving parts data from the global data loaded via /api/data
                            const movingPartsData = window.rmaMovingPartsData && window.rmaMovingPartsData[rmaId] ? window.rmaMovingPartsData[rmaId] : [];
                            
                            if (movingPartsData.length > 0) {
                                // Cache the data
                                cacheEntry.data = { success: true, movingParts: movingPartsData };
                                cacheEntry.isLoaded = true;
                                
                                const formattedMovingParts = self.formatMovingPartsForPopover(movingPartsData);
                                
                                // Update the existing popover's content
                                const currentPopover = bootstrap.Popover.getInstance(icon);
                                if (currentPopover) {
                                    // Update the popover's tip content if it's already shown
                                    const popoverTip = currentPopover.tip;
                                    if (popoverTip) {
                                        const popoverBody = popoverTip.querySelector('.popover-body');
                                        if (popoverBody) {
                                            popoverBody.innerHTML = formattedMovingParts;
                                        }
                                        const popoverHeader = popoverTip.querySelector('.popover-header');
                                        if (popoverHeader) {
                                            popoverHeader.textContent = `Moving Parts (${movingPartsData.length})`;
                                        }
                                    }
                                    
                                    // Also update the data attributes for future shows
                                    icon.setAttribute('data-bs-content', formattedMovingParts);
                                    icon.setAttribute('data-bs-title', `Moving Parts (${movingPartsData.length})`);
                                }
                            } else {
                                console.log(`No moving parts data found for RMA ${rmaId}`);
                                const noDataMessage = 'No moving parts recorded';
                                
                                // Cache the empty result
                                cacheEntry.data = { success: true, movingParts: [] };
                                cacheEntry.isLoaded = true;
                                
                                const currentPopover = bootstrap.Popover.getInstance(icon);
                                if (currentPopover) {
                                    const popoverTip = currentPopover.tip;
                                    if (popoverTip) {
                                        const popoverBody = popoverTip.querySelector('.popover-body');
                                        if (popoverBody) {
                                            popoverBody.innerHTML = noDataMessage;
                                        }
                                    }
                                    
                                    // Also update the data attributes for future shows
                                    icon.setAttribute('data-bs-content', noDataMessage);
                                }
                            }
                        } catch (error) {
                            console.error('Error processing moving parts data:', error);
                            const errorMessage = 'Error loading moving parts';
                            
                            const currentPopover = bootstrap.Popover.getInstance(icon);
                            if (currentPopover) {
                                const popoverTip = currentPopover.tip;
                                if (popoverTip) {
                                    const popoverBody = popoverTip.querySelector('.popover-body');
                                    if (popoverBody) {
                                        popoverBody.innerHTML = errorMessage;
                                    }
                                }
                                
                                // Also update the data attributes for future shows
                                icon.setAttribute('data-bs-content', errorMessage);
                            }
                        } finally {
                            cacheEntry.isLoading = false;
                        }
                    });
                });
            },

            formatMovingPartsForPopover(movingParts) {
                if (!movingParts || movingParts.length === 0) {
                    return 'No moving parts available';
                }
                
                return movingParts.map(part => {
                    const formatDate = (dateStr) => {
                        if (!dateStr) return 'Unknown date';
                        try {
                            const date = new Date(dateStr);
                            return date.toLocaleDateString('en-US', { 
                                month: '2-digit', 
                                day: '2-digit', 
                                year: '2-digit'
                            });
                        } catch {
                            return 'Unknown date';
                        }
                    };
                    
                    return `<div class="mb-2">
                        <strong>${part.partName || part.partNumber || 'Unknown Part'}</strong><br/>
                        <small class="text-muted">
                            From: ${part.fromLocation || 'Unknown'} → To: ${part.toLocation || 'Unknown'}<br/>
                            Date: ${formatDate(part.movementDate)}
                        </small>
                    </div>`;
                }).join('<hr class="my-1"/>');
            }
        };

        // Function to initialize clickable table rows
        function initializeClickableRows() {
            const rmaRows = document.querySelectorAll('.rma-row');
            rmaRows.forEach(row => {
                // Check if already has click handler to avoid duplicates
                if (row.hasAttribute('data-click-initialized')) {
                    return;
                }
                
                row.setAttribute('data-click-initialized', 'true');
                row.addEventListener('click', function(e) {
                    // Don't navigate if we just finished dragging
                    const tableContainer = document.querySelector('.rma-table-container');
                    if (tableContainer && tableContainer.hasDragged) {
                        return;
                    }
                    
                    // Don't navigate if clicking on interactive elements
                    if (e.target.closest('a, button, input, .dropdown, [data-bs-toggle], .moving-parts-icon, .problem-popover-icon, .info-icon-interactive, .interactive-icon, .tool-tooltip, .comment-icon')) {
                        return;
                    }
                    
                    // Get the RMA ID from the row's data attribute or from icon elements
                    let rmaId = row.getAttribute('data-rma-id');
                    
                    if (!rmaId) {
                        // Fallback to getting RMA ID from icon elements (for server-rendered rows)
                        const problemIcon = row.querySelector('.problem-popover-icon');
                        if (problemIcon) {
                            rmaId = problemIcon.getAttribute('data-rma-id');
                        }
                        
                        if (!rmaId) {
                            const commentIcon = row.querySelector('.comment-icon');
                            if (commentIcon) {
                                rmaId = commentIcon.getAttribute('data-rma-id');
                            }
                        }
                        
                        if (!rmaId) {
                            const toolIcon = row.querySelector('.tool-tooltip');
                            if (toolIcon) {
                                rmaId = toolIcon.getAttribute('data-rma-id');
                            }
                        }
                    }
                    
                    if (rmaId) {
                        window.location.href = `/rma/${rmaId}`;
                    }
                });
            });
        }

        // Initialize async loading or regular RMA manager
        document.addEventListener('DOMContentLoaded', function() {
            const loadingContainer = document.getElementById('rma-loading-container');
            
            if (loadingContainer) {
                // Async loading mode
                AsyncRMALoader.init();
            } else {
                // Regular mode
                new RMAManager();
            }
            
            // Enhanced horizontal scrolling functionality
            const tableContainer = document.querySelector('.rma-table-container');
            
            if (tableContainer) {
                // Shift + mouse wheel for horizontal scrolling
                tableContainer.addEventListener('wheel', function(e) {
                    if (e.shiftKey) {
                        e.preventDefault();
                        tableContainer.scrollLeft += e.deltaY;
                    }
                });
                
                // Click and drag to scroll horizontally
                let isDown = false;
                let startX;
                let scrollLeft;
                let hasDragged = false;
                
                // Make hasDragged accessible to row click handlers
                tableContainer.hasDragged = false;
                
                tableContainer.addEventListener('mousedown', function(e) {
                    // Only start drag if clicking on the container itself, not interactive elements
                    if (e.target.closest('a, button, input, .dropdown, [data-bs-toggle]')) {
                        return;
                    }
                    
                    isDown = true;
                    hasDragged = false;
                    tableContainer.hasDragged = false;
                    tableContainer.classList.add('dragging');
                    startX = e.pageX - tableContainer.offsetLeft;
                    scrollLeft = tableContainer.scrollLeft;
                });
                
                tableContainer.addEventListener('mouseleave', function() {
                    isDown = false;
                    tableContainer.classList.remove('dragging');
                    // Reset drag flag after a longer delay
                    setTimeout(() => { 
                        hasDragged = false; 
                        tableContainer.hasDragged = false;
                    }, 200);
                });
                
                tableContainer.addEventListener('mouseup', function() {
                    isDown = false;
                    tableContainer.classList.remove('dragging');
                    // Reset drag flag after a longer delay to allow click detection
                    setTimeout(() => { 
                        hasDragged = false; 
                        tableContainer.hasDragged = false;
                    }, 200);
                });
                
                tableContainer.addEventListener('mousemove', function(e) {
                    if (!isDown) return;
                    e.preventDefault();
                    const x = e.pageX - tableContainer.offsetLeft;
                    const walk = (x - startX) * 2; // Scroll speed multiplier
                    
                    // Mark as dragged if mouse moved more than 3 pixels (more sensitive)
                    if (Math.abs(walk) > 3) {
                        hasDragged = true;
                        tableContainer.hasDragged = true;
                    }
                    
                    tableContainer.scrollLeft = scrollLeft - walk;
                });
                
                // Keyboard arrow keys for horizontal scrolling
                document.addEventListener('keydown', function(e) {
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                    
                    if (e.key === 'ArrowLeft' && e.shiftKey) {
                        e.preventDefault();
                        tableContainer.scrollLeft -= 50;
                    } else if (e.key === 'ArrowRight' && e.shiftKey) {
                        e.preventDefault();
                        tableContainer.scrollLeft += 50;
                                         }
                 });
                 
                                 // Initialize clickable table rows
                initializeClickableRows();
             }
        });
    </script>
    
    <!-- Excel Export Functionality -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const exportBtn = document.getElementById('exportToExcelBtn');
            
            if (exportBtn) {
                exportBtn.addEventListener('click', function() {
                    exportToExcel();
                });
            }
        });
        
        function exportToExcel() {
            // Show loading state
            const exportBtn = document.getElementById('exportToExcelBtn');
            const originalHtml = exportBtn.innerHTML;
            exportBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i>Exporting...';
            exportBtn.disabled = true;
            
            try {
                // Collect current filters
                const filters = getCurrentFilters();
                
                // Create form data
                const formData = new FormData();
                formData.append('searchTerm', filters.searchTerm || '');
                formData.append('statusFilters', JSON.stringify(filters.statusFilters));
                formData.append('sortBy', filters.sortBy || '');
                formData.append('sortDirection', filters.sortDirection || 'desc');
                
                // Create and submit form
                const form = document.createElement('form');
                form.method = 'POST';
                form.action = '/rma/export-excel';
                form.style.display = 'none';
                
                // Add form data as hidden inputs
                formData.forEach((value, key) => {
                    const input = document.createElement('input');
                    input.type = 'hidden';
                    input.name = key;
                    input.value = value;
                    form.appendChild(input);
                });
                
                document.body.appendChild(form);
                form.submit();
                document.body.removeChild(form);
                
                // Reset button after a short delay
                setTimeout(() => {
                    exportBtn.innerHTML = originalHtml;
                    exportBtn.disabled = false;
                }, 2000);
                
            } catch (error) {
                console.error('Error exporting to Excel:', error);
                alert('Error exporting to Excel. Please try again.');
                
                // Reset button
                exportBtn.innerHTML = originalHtml;
                exportBtn.disabled = false;
            }
        }
        
        function getCurrentFilters() {
            // Get search term
            const searchInput = document.getElementById('rmaSearchInput');
            const searchTerm = searchInput ? searchInput.value : '';
            
            // Get status filters
            const statusCheckboxes = document.querySelectorAll('.status-filter:checked');
            const statusFilters = Array.from(statusCheckboxes).map(cb => cb.value);
            
            // Get current sort (if available)
            let sortBy = '';
            let sortDirection = 'desc';
            
            // Check for sort indicators in table headers
            const activeSort = document.querySelector('.sortable-header.sort-active');
            if (activeSort) {
                sortBy = activeSort.getAttribute('data-sort');
                sortDirection = activeSort.classList.contains('sort-asc') ? 'asc' : 'desc';
            }
            
            return {
                searchTerm: searchTerm,
                statusFilters: statusFilters,
                sortBy: sortBy,
                sortDirection: sortDirection
            };
        }
    </script>
    
    <!-- Bootstrap JavaScript - MUST load before theme toggle for dropdowns to work -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <!-- Theme Toggle JavaScript -->
    <script th:src="@{/js/theme-toggle.js}"></script>
    
        <!-- Dropdown fix for RMA page -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Fix dropdown functionality on this page
            const statusDropdown = document.getElementById('statusFilterDropdown');
            const priorityDropdown = document.getElementById('priorityFilterDropdown');
            const profileDropdown = document.getElementById('profileDropdown');
            
            if (statusDropdown) {
                statusDropdown.addEventListener('click', function(e) {
                    e.stopPropagation();
                    e.preventDefault();
                    const dropdownInstance = bootstrap.Dropdown.getInstance(statusDropdown) || new bootstrap.Dropdown(statusDropdown);
                    dropdownInstance.toggle();
                });
            }
            
            if (priorityDropdown) {
                priorityDropdown.addEventListener('click', function(e) {
                    e.stopPropagation();
                    e.preventDefault();
                    const dropdownInstance = bootstrap.Dropdown.getInstance(priorityDropdown) || new bootstrap.Dropdown(priorityDropdown);
                    dropdownInstance.toggle();
                });
            }
            
            if (profileDropdown) {
                profileDropdown.addEventListener('click', function(e) {
                    e.stopPropagation();
                    e.preventDefault();
                    const dropdownInstance = bootstrap.Dropdown.getInstance(profileDropdown) || new bootstrap.Dropdown(profileDropdown);
                    dropdownInstance.toggle();
                });
            }
            
            // Make status filter rows clickable to toggle checkboxes
            document.querySelectorAll('.status-filter-item').forEach(function(item) {
                item.style.cursor = 'pointer';
                item.addEventListener('click', function(e) {
                    // Don't trigger if clicking directly on the checkbox
                    if (e.target.type === 'checkbox') {
                        return;
                    }
                    
                    // Find the checkbox within this item
                    const checkbox = item.querySelector('.status-filter');
                    if (checkbox) {
                        // Toggle the checkbox
                        checkbox.checked = !checkbox.checked;
                        
                        // Trigger the change event to update the filtering
                        const event = new Event('change', { bubbles: true });
                        checkbox.dispatchEvent(event);
                    }
                    
                    // Prevent the dropdown from closing
                    e.stopPropagation();
                });
            });

            // Make priority filter rows clickable to toggle checkboxes
            document.querySelectorAll('.priority-filter-item').forEach(function(item) {
                item.style.cursor = 'pointer';
                item.addEventListener('click', function(e) {
                    // Don't trigger if clicking directly on the checkbox
                    if (e.target.type === 'checkbox') {
                        return;
                    }
                    
                    // Find the checkbox within this item
                    const checkbox = item.querySelector('.priority-filter');
                    if (checkbox) {
                        // Toggle the checkbox
                        checkbox.checked = !checkbox.checked;
                        
                        // Trigger the change event to update the filtering
                        const event = new Event('change', { bubbles: true });
                        checkbox.dispatchEvent(event);
                    }
                    
                    // Prevent the dropdown from closing
                    e.stopPropagation();
                });
            });


        });
    </script>
</body>
</html> 